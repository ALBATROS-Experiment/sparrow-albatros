{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sparrow Albatros This repository serves three purpouses. The first is to house and version control embedded software that runs on the Sparrow's ARM's processor. The second is to house and version control gateware that runs on the Sparrow's FPGA. The third is to store and checkpoint disk-images of the OS that run the data acquisition software. The embedded software mates with the gateware, so it's conveniant to track them in the same repository. We use git-lfs to track the OS disk-images and exclude them from downloading by default. By tracking disk images here we we can recreate a bit-accurate release of sparrow-albatros without relying on anything outside of this repository. Embedded software We're running Ubunto on the on the Zynq's ARM core. The software that runs on this processor controls. This software can be found in the /software directory. Everything in this repository that runs on the ARM core comes from this directory. Gateware Disk Images","title":"Home"},{"location":"#sparrow-albatros","text":"This repository serves three purpouses. The first is to house and version control embedded software that runs on the Sparrow's ARM's processor. The second is to house and version control gateware that runs on the Sparrow's FPGA. The third is to store and checkpoint disk-images of the OS that run the data acquisition software. The embedded software mates with the gateware, so it's conveniant to track them in the same repository. We use git-lfs to track the OS disk-images and exclude them from downloading by default. By tracking disk images here we we can recreate a bit-accurate release of sparrow-albatros without relying on anything outside of this repository.","title":"Sparrow Albatros"},{"location":"#embedded-software","text":"We're running Ubunto on the on the Zynq's ARM core. The software that runs on this processor controls. This software can be found in the /software directory. Everything in this repository that runs on the ARM core comes from this directory.","title":"Embedded software"},{"location":"#gateware","text":"","title":"Gateware"},{"location":"#disk-images","text":"","title":"Disk Images"},{"location":"collecting-data-in-depth/","text":"","title":"Collecting data (in depth)"},{"location":"collecting-data-quickstart/","text":"We start from the assumption that you have correctly setup the Sparrow-Albatros readout system. Boot and tunnel into the Sparrow Power the RF-shielded box with a 24V power supply through the barrel port labelled IN. The Zynq's ARM core will boot off of the SD card mounted in the Sparrow's SD card slot. Connect your laptop to the Sparrow using an ethernet cable. If you have trouble with the next two steps you may need to configure the ethernet interface manually to be on the 10.10.xx.xx subnet (subnet mask 255.255.0.0, with an IP address e.g. 10.10.11.55) Check that you can connect to the Sparrow with ping 10.10.11.99 . The Sparrow's IP address on this LAN is set statically and should not change. Then ssh into the Sparrow with ssh casper@10.10.11.99 . When prompted Collecting data Now that you've tunneled in, you can run data collection. Find out the name of the drive connected with lsblk , it will probably be sda1 Mount the drive sudo mount /dev/sda1 /media/BASEBAND Navigate to the software directory cd ~/sparrow-albatros/software Modify the user configuration file config.ini to fit your needs Configure the FPGA with python configfpga.py and make sure the switch's lights are flashing consistently. Start a screen session for recording the on board correlations screen -S spec From this screen session run python dump_spectra.py Detach yourself from the screen session with ctrl + a + d Start a new screen session for running the baseband collection script screen -S baseband If you are collecting 4-bit data run python set_optimal_coeffs.py , this uses the on board correlation to optimally set the digital gain coefficients at the requantization stage. [!NOTE] This can only be run at least 15 seconds after the FPGA has been configured (step 5) Compile the c-code that reads UDP packets and writes them to disk with make clean;make Run the c-code with superuser privilages sudo ./dump_baseband Detach yourself from the screen session ctrl + a + d Check that on-board correlations are being written to ~/data_auto_cross and that baseband is being written to /media/BASEBAND/baseband . An easy way to do this is to ls -lh multiple times and watch files grow.","title":"Collecting data (quick start)"},{"location":"collecting-data-quickstart/#boot-and-tunnel-into-the-sparrow","text":"Power the RF-shielded box with a 24V power supply through the barrel port labelled IN. The Zynq's ARM core will boot off of the SD card mounted in the Sparrow's SD card slot. Connect your laptop to the Sparrow using an ethernet cable. If you have trouble with the next two steps you may need to configure the ethernet interface manually to be on the 10.10.xx.xx subnet (subnet mask 255.255.0.0, with an IP address e.g. 10.10.11.55) Check that you can connect to the Sparrow with ping 10.10.11.99 . The Sparrow's IP address on this LAN is set statically and should not change. Then ssh into the Sparrow with ssh casper@10.10.11.99 . When prompted","title":"Boot and tunnel into the Sparrow"},{"location":"collecting-data-quickstart/#collecting-data","text":"Now that you've tunneled in, you can run data collection. Find out the name of the drive connected with lsblk , it will probably be sda1 Mount the drive sudo mount /dev/sda1 /media/BASEBAND Navigate to the software directory cd ~/sparrow-albatros/software Modify the user configuration file config.ini to fit your needs Configure the FPGA with python configfpga.py and make sure the switch's lights are flashing consistently. Start a screen session for recording the on board correlations screen -S spec From this screen session run python dump_spectra.py Detach yourself from the screen session with ctrl + a + d Start a new screen session for running the baseband collection script screen -S baseband If you are collecting 4-bit data run python set_optimal_coeffs.py , this uses the on board correlation to optimally set the digital gain coefficients at the requantization stage. [!NOTE] This can only be run at least 15 seconds after the FPGA has been configured (step 5) Compile the c-code that reads UDP packets and writes them to disk with make clean;make Run the c-code with superuser privilages sudo ./dump_baseband Detach yourself from the screen session ctrl + a + d Check that on-board correlations are being written to ~/data_auto_cross and that baseband is being written to /media/BASEBAND/baseband . An easy way to do this is to ls -lh multiple times and watch files grow.","title":"Collecting data"},{"location":"gateware-design/","text":"The digital signal processing logic starts at the ADCs, gets PFB'd (Filter + FFT), then splits into two signal paths: 1. The logic re-quantizes the signal to 1 or 4 bits then selects and packages a subset of frequency channels into UDP packets which are streamed out of the Sparrow's 0'th SFP port. 2. On board auto and cross correlations which can be read by the ARM core over SPI. Forword on the Simulink-CASPER gateware design paradigm The Simulink (Matlab) and CASPER framework abstracts away the nitty gritty plumbing inherent to modern (2025) FPGA programming in regular text-based HDLs. There are good, bad, and ugly things about this. On the good side, the user can jump right in and design, simulate, compile, implement, and synthesise a basic design targeted for a supported FPGA. The simulation aspect is worth emphasising because it's very easy to write a bug into logic design and it's often very hard to catch it without simulation. On the bad side it is impossible to track small diffs with modern version control tools (git) between two commits because the .slx files, being diagramatic rather than text based, are big and stored in compressed binary format. And the ugly side which is that the toolchain is very brittle and annoying to set up. Once you have the toolchain running and are ready to assemble your first design, you'll notice that there are many different types of color-coded block. - The yellow (CASPER) blocks are IO bocks. They map hardware pins to logic, define user programmable BRAMS and registers - The green (CASPER) blocks are (vaguely) DSP blocks. They implement logic to manipulate data. - The blue Xilinx blocks mix memory access and logic and are provided by Xilinx. These are primitive blocks provided by Xilinx, like operators or primitive data types in C. - Some white blocks implement simulation-only logic and tools to help develop and simulate the gateware. - The glossy grey blocks are user-defined subsystems that abstract away complexity, like a function in C or Python. Some white blocks also abstract user-defined logic, but these ones have 'mask parameters'. The values of mask parameters are set by the user before compilation, just like C macro-definitions. You can create one by highlighting some logic, righ-clicking, and selecting 'create subsystem from selection'. You can then turn a subsystem into a block with mask parameters by right-clicking the subsystem then Mask > Create Mask. ADC interface The ADC interface block, labelled sparrow_adc , provides the plumbing to link the ADCs' output pins with the design. The sync_adc register provides an interface for the python framework to sync the ADCs. The ADCs are programmed to sample at 250 MSPS but the fabric clock in this design is configured to run at 125 MSPS. To accomplish this clock domain crossing ADC samples are loaded into the fabric two at a time from each Pol (analog channel). The four output pins labels data_a/b_0/1 denote a/b for pol0/1 and 0/1 for first and second samples within one fabric-clock period. PFB FIR The Polyphase Filter Bank Finite Impulse Response stage comprises four (number of inputs) sets of a series of four (number of taps) shift registers. Four frames worth of data from each ADC is windowed (point-wise multiplied by a vector of 'window coefficients'), then stacked and summed vertically. The output of this FIR filter feeds into the FFT. Each frame is 4096 (2^12) samples wide. The sync register is a user-writeable register which creates a 'sync pulse'. The sync pulse serves to align frames output by the PFB FIR filter with all of the logic downstream of it. This digital signal chain comprises an infinite loop of the same operations on consecutive data-frames and the sync pulse tells all the logical operators when the begining and end of each frame is. FFT The FFT block implements a highly optimized Radix-2 decomposition Decimation In Frequency Fast Fourier Transform on parallel inputs. It takes a user-defined shift schedule as input ( pfb_fft_shift ) and records overflow events in a the register named fft_of_count . This FFT implementation takes advantage of the fact that a real-to-complex DFT has half as many outputs as inputs to balance the fact that it's being fed two samples from each ADC simultaneously. It also incorporates a de-scrambler so that the outputs are frequency-ordered complex samples (DIF FFTs naturally scramble their output (frequency domain samples) into bit-reversed order). TODO: inside the FFT TVG1 The first Test Vector Generator follows immediately downstream of the FFT. (The two green bus_create / bus_expand blocks don't modify the data whatsoever but simply package the 36/72 parallel bit-lines together/appart.) A TVG is a simple bit of logic that empowers the user to mux in values from a user-writeable BRAM instead of the input. This module exists can help test and debug gateware both at the simulation stage and in-Silica. The user controls whether to let actual data pass with the enable register, and what data to replace it with by writing to the data BRAM. Requantization After the TVG the signal is split three ways. The first two requantize the same complex digital signal--in parallel--to 1+1-bit and 4+4-bits respectively. (Each of the real and imaginary components of each sample is quantized to 1 or 4 bits.) Data re-ordering and bussifying follows both one-bit and four-bit requantization stages. The output order is defined by the user so that the frequency channels to be packetized come out first. Both 1bit and 4bit data is 'bussified' onto an 8-bit bus. 8-bits is not wide enough for the 4-bit data (4 bits ADC0 real + 4 bits ADC0 imaginary + 4 bits ADC1 real + 4 bits ADC1 imaginary = 16 bits per clock), which is why the re-order stage must come before the bussifying stage. This limits the number of selectable channels to 1024 of 2048. The one bit re-quantization logic is just a bunch of comparators (> or <). In parallel we quantize each component (real/imaginary) of each frequency channel to four bits. To exploit the full range of bits excersised by 4-bit quantization we apply digital gain to each frequency channel individually. The gain in each channel is set by the user through the coeffs_pol0 / coeffs_pol1 registers. The result is saturated against a floor and ceiling of the 4-bit range (-/+0.875) to wrapping (overflow). This image shows the logic for one of four quantization signal paths is shown. Packetiser The packetiser TODO: explaim more blah blih blough Lorum Ipsum Comunitatus Once the data has been packetized, it goes into the one_gbe block, and the CASPER framework takes care of the plumbing to pipe this into the correct Xilinx IP that implements UDP packetizing, and routs it to the correct physical SFP port (SFP0). In the image, a helpful user-readable buffer-overflow counter tx_of_cnt keeps track of overflowing packets, and the signal coming out of our user-defined packetizer also routs in simulation only to a virtual oscilascope. On board Correlator The signal splits into another path after the FFT into an on-chip correlator. This design targets the Sparrow board which only has two ADC inputs (known colloquially as 'pol0' and 'pol1'). The power in each pol is computed with a simple accumulator. Real and imaginary components of the cross correlation are similarly calculated. The result is dumped periodically into addressable BRAM registers pol00 , pol11 , pol01r , pol01i . User read/writeable registers We make use of all named addressable registers in this design so it's worth knowing what each of them does. (The left-pointing pentagonal tags mean goto and are paired with right-pointing ones of the same name.) - gbe_en GigaBit Ethernet interface ENable. Single bit, 0 for disable, 1 for enable. - gbe_rst GigaBit Ethernet interface ReSeT. Single bit. Resets on transition from 0 to 1. - pack_rst PACKetizer ReSeT. Single bit to reset packetizer logic, including spectrum counter, on transition from 0 to 1. - cnt_rst accumulator CoNTroller ReSeT. Single bit to reset accumulator control logic. - acc_len ACCumulation LENgth. UFix32 sets the number of spectra to accumulate for each correlation. (How long to integrate data, if you prefer to think that way.) This number times 4096/250e6 gives the accumulation time in seconds. - dest_ip Sets the DESTination IP addresss. - dest_prt Sets the DESTination PoRT. - sync_cnt (read only) does exactly nothing because I removed the logic that periodically syncs all the logic. Instead it just syncs stuff once on initialization. - acc_cnt (read_only) ACCumulation CouNTer. Counts the number of spectra that have been accumulated. Other user read/writeable registers are scattered throughout the design. sync_adc SYNChronize ADC logic. Single bit pulse active on transition from 0 to 1. sync Creates SYNChronizing pulse that aligns each set of the DSP chain. Single bit pulse, active on transition from 0 to 1. pfb_fft_shift UFix12 determines the shift schedule. Each bit represents 0 for no shift, 1 for shift. Currently we have a full shift schedule. We may want to implement a bit-growth FFT so that we can have our cake (low noise floor from not shifting) and eat it too (no FFT overflows). fft_of_count (read only) FFT OverFlow COUNTer. Every time there's an overflow event in a frame +1 is added to this UFix32 register. sel SELects which requantization bit mode to choose from: 0 for 1bit, 1 for 4bits. tvg1_enable Enables the the TVG right after the FFT stage. 0 to pass actual data, 1 to pass values read sequentially from the BRAM labelled data . tvg16bit_enable Enables the the TVG right after the 4bit requantization stage. 0 to pass actual data, 1 to pass values read sequentially from the BRAM labelled data . four_bit_quant_clip_count TODO spectra_per_packet TODO bytes_per_spectrum TODO tx_of_cnt TODO User BRAM interfaces tvg1_data TODO tvg16bit_data TODO four_bit_quant_coeffs_pol0/1 TODO one_bit_reorder_map1 TODO four_bit_reorder_map1 TODO pol00 , pol11 , pol01r , pol01i TODO","title":"Gateware overview"},{"location":"gateware-design/#forword-on-the-simulink-casper-gateware-design-paradigm","text":"The Simulink (Matlab) and CASPER framework abstracts away the nitty gritty plumbing inherent to modern (2025) FPGA programming in regular text-based HDLs. There are good, bad, and ugly things about this. On the good side, the user can jump right in and design, simulate, compile, implement, and synthesise a basic design targeted for a supported FPGA. The simulation aspect is worth emphasising because it's very easy to write a bug into logic design and it's often very hard to catch it without simulation. On the bad side it is impossible to track small diffs with modern version control tools (git) between two commits because the .slx files, being diagramatic rather than text based, are big and stored in compressed binary format. And the ugly side which is that the toolchain is very brittle and annoying to set up. Once you have the toolchain running and are ready to assemble your first design, you'll notice that there are many different types of color-coded block. - The yellow (CASPER) blocks are IO bocks. They map hardware pins to logic, define user programmable BRAMS and registers - The green (CASPER) blocks are (vaguely) DSP blocks. They implement logic to manipulate data. - The blue Xilinx blocks mix memory access and logic and are provided by Xilinx. These are primitive blocks provided by Xilinx, like operators or primitive data types in C. - Some white blocks implement simulation-only logic and tools to help develop and simulate the gateware. - The glossy grey blocks are user-defined subsystems that abstract away complexity, like a function in C or Python. Some white blocks also abstract user-defined logic, but these ones have 'mask parameters'. The values of mask parameters are set by the user before compilation, just like C macro-definitions. You can create one by highlighting some logic, righ-clicking, and selecting 'create subsystem from selection'. You can then turn a subsystem into a block with mask parameters by right-clicking the subsystem then Mask > Create Mask.","title":"Forword on the Simulink-CASPER gateware design paradigm"},{"location":"gateware-design/#adc-interface","text":"The ADC interface block, labelled sparrow_adc , provides the plumbing to link the ADCs' output pins with the design. The sync_adc register provides an interface for the python framework to sync the ADCs. The ADCs are programmed to sample at 250 MSPS but the fabric clock in this design is configured to run at 125 MSPS. To accomplish this clock domain crossing ADC samples are loaded into the fabric two at a time from each Pol (analog channel). The four output pins labels data_a/b_0/1 denote a/b for pol0/1 and 0/1 for first and second samples within one fabric-clock period.","title":"ADC interface"},{"location":"gateware-design/#pfb-fir","text":"The Polyphase Filter Bank Finite Impulse Response stage comprises four (number of inputs) sets of a series of four (number of taps) shift registers. Four frames worth of data from each ADC is windowed (point-wise multiplied by a vector of 'window coefficients'), then stacked and summed vertically. The output of this FIR filter feeds into the FFT. Each frame is 4096 (2^12) samples wide. The sync register is a user-writeable register which creates a 'sync pulse'. The sync pulse serves to align frames output by the PFB FIR filter with all of the logic downstream of it. This digital signal chain comprises an infinite loop of the same operations on consecutive data-frames and the sync pulse tells all the logical operators when the begining and end of each frame is.","title":"PFB FIR"},{"location":"gateware-design/#fft","text":"The FFT block implements a highly optimized Radix-2 decomposition Decimation In Frequency Fast Fourier Transform on parallel inputs. It takes a user-defined shift schedule as input ( pfb_fft_shift ) and records overflow events in a the register named fft_of_count . This FFT implementation takes advantage of the fact that a real-to-complex DFT has half as many outputs as inputs to balance the fact that it's being fed two samples from each ADC simultaneously. It also incorporates a de-scrambler so that the outputs are frequency-ordered complex samples (DIF FFTs naturally scramble their output (frequency domain samples) into bit-reversed order). TODO: inside the FFT","title":"FFT"},{"location":"gateware-design/#tvg1","text":"The first Test Vector Generator follows immediately downstream of the FFT. (The two green bus_create / bus_expand blocks don't modify the data whatsoever but simply package the 36/72 parallel bit-lines together/appart.) A TVG is a simple bit of logic that empowers the user to mux in values from a user-writeable BRAM instead of the input. This module exists can help test and debug gateware both at the simulation stage and in-Silica. The user controls whether to let actual data pass with the enable register, and what data to replace it with by writing to the data BRAM.","title":"TVG1"},{"location":"gateware-design/#requantization","text":"After the TVG the signal is split three ways. The first two requantize the same complex digital signal--in parallel--to 1+1-bit and 4+4-bits respectively. (Each of the real and imaginary components of each sample is quantized to 1 or 4 bits.) Data re-ordering and bussifying follows both one-bit and four-bit requantization stages. The output order is defined by the user so that the frequency channels to be packetized come out first. Both 1bit and 4bit data is 'bussified' onto an 8-bit bus. 8-bits is not wide enough for the 4-bit data (4 bits ADC0 real + 4 bits ADC0 imaginary + 4 bits ADC1 real + 4 bits ADC1 imaginary = 16 bits per clock), which is why the re-order stage must come before the bussifying stage. This limits the number of selectable channels to 1024 of 2048. The one bit re-quantization logic is just a bunch of comparators (> or <). In parallel we quantize each component (real/imaginary) of each frequency channel to four bits. To exploit the full range of bits excersised by 4-bit quantization we apply digital gain to each frequency channel individually. The gain in each channel is set by the user through the coeffs_pol0 / coeffs_pol1 registers. The result is saturated against a floor and ceiling of the 4-bit range (-/+0.875) to wrapping (overflow). This image shows the logic for one of four quantization signal paths is shown.","title":"Requantization"},{"location":"gateware-design/#packetiser","text":"The packetiser TODO: explaim more blah blih blough Lorum Ipsum Comunitatus Once the data has been packetized, it goes into the one_gbe block, and the CASPER framework takes care of the plumbing to pipe this into the correct Xilinx IP that implements UDP packetizing, and routs it to the correct physical SFP port (SFP0). In the image, a helpful user-readable buffer-overflow counter tx_of_cnt keeps track of overflowing packets, and the signal coming out of our user-defined packetizer also routs in simulation only to a virtual oscilascope.","title":"Packetiser"},{"location":"gateware-design/#on-board-correlator","text":"The signal splits into another path after the FFT into an on-chip correlator. This design targets the Sparrow board which only has two ADC inputs (known colloquially as 'pol0' and 'pol1'). The power in each pol is computed with a simple accumulator. Real and imaginary components of the cross correlation are similarly calculated. The result is dumped periodically into addressable BRAM registers pol00 , pol11 , pol01r , pol01i .","title":"On board Correlator"},{"location":"gateware-design/#user-readwriteable-registers","text":"We make use of all named addressable registers in this design so it's worth knowing what each of them does. (The left-pointing pentagonal tags mean goto and are paired with right-pointing ones of the same name.) - gbe_en GigaBit Ethernet interface ENable. Single bit, 0 for disable, 1 for enable. - gbe_rst GigaBit Ethernet interface ReSeT. Single bit. Resets on transition from 0 to 1. - pack_rst PACKetizer ReSeT. Single bit to reset packetizer logic, including spectrum counter, on transition from 0 to 1. - cnt_rst accumulator CoNTroller ReSeT. Single bit to reset accumulator control logic. - acc_len ACCumulation LENgth. UFix32 sets the number of spectra to accumulate for each correlation. (How long to integrate data, if you prefer to think that way.) This number times 4096/250e6 gives the accumulation time in seconds. - dest_ip Sets the DESTination IP addresss. - dest_prt Sets the DESTination PoRT. - sync_cnt (read only) does exactly nothing because I removed the logic that periodically syncs all the logic. Instead it just syncs stuff once on initialization. - acc_cnt (read_only) ACCumulation CouNTer. Counts the number of spectra that have been accumulated. Other user read/writeable registers are scattered throughout the design. sync_adc SYNChronize ADC logic. Single bit pulse active on transition from 0 to 1. sync Creates SYNChronizing pulse that aligns each set of the DSP chain. Single bit pulse, active on transition from 0 to 1. pfb_fft_shift UFix12 determines the shift schedule. Each bit represents 0 for no shift, 1 for shift. Currently we have a full shift schedule. We may want to implement a bit-growth FFT so that we can have our cake (low noise floor from not shifting) and eat it too (no FFT overflows). fft_of_count (read only) FFT OverFlow COUNTer. Every time there's an overflow event in a frame +1 is added to this UFix32 register. sel SELects which requantization bit mode to choose from: 0 for 1bit, 1 for 4bits. tvg1_enable Enables the the TVG right after the FFT stage. 0 to pass actual data, 1 to pass values read sequentially from the BRAM labelled data . tvg16bit_enable Enables the the TVG right after the 4bit requantization stage. 0 to pass actual data, 1 to pass values read sequentially from the BRAM labelled data . four_bit_quant_clip_count TODO spectra_per_packet TODO bytes_per_spectrum TODO tx_of_cnt TODO","title":"User read/writeable registers"},{"location":"gateware-design/#user-bram-interfaces","text":"tvg1_data TODO tvg16bit_data TODO four_bit_quant_coeffs_pol0/1 TODO one_bit_reorder_map1 TODO four_bit_reorder_map1 TODO pol00 , pol11 , pol01r , pol01i TODO","title":"User BRAM interfaces"},{"location":"gateware-documentation/","text":"Once you've got the toolchain up and running on a beefy computer... Modify the design matlab... Synthesize and Implement the design lorum ipsum compiliation (mlab - hdl) > synthesis (hdl - logic) > implementation (logic - hardware) Open up the synthesized design in Vivado and check timing","title":"Gateware"},{"location":"gateware-documentation/#modify-the-design","text":"matlab...","title":"Modify the design"},{"location":"gateware-documentation/#synthesize-and-implement-the-design","text":"lorum ipsum compiliation (mlab - hdl) > synthesis (hdl - logic) > implementation (logic - hardware) Open up the synthesized design in Vivado and check timing","title":"Synthesize and Implement the design"},{"location":"installing-sparrow-albatros/","text":"We're running Ubuntu 18.04.6 LTS (Bionic Beaver) on the Sparrow's ARM processor. Quick start You have all the hardware for a Sparrow-Albatros data acquisition system and you want to get the software up and running for data collection. Easy, just download the latest image from os-sd-images directory , unzip it, and write it onto a fresh SD card. To save time writing the image we shrink the main filesystem partition. If the image hasn't automatically resized, make sure to resize the partition so that it takes up the full disk space. To do this: - Insert the SD card into a linux machine or computer, if using an SD card sleeve, make sure it is in writable mode (physical slot switched upwards, towards metal) - If it auto-mounts, unmount it - Open gparted as superuser sudo gparted - Select the volume corresponding to the SD card - Resize the filesystem partition \"rootfs\" so that it fills the remaining disk space (right-click, resize, drag and drop, click green tick box apply all operations ) Stick the card into the Sparrow board's microSD card slot and you're good to go!","title":"Installing Sparrow Albatros"},{"location":"installing-sparrow-albatros/#quick-start","text":"You have all the hardware for a Sparrow-Albatros data acquisition system and you want to get the software up and running for data collection. Easy, just download the latest image from os-sd-images directory , unzip it, and write it onto a fresh SD card. To save time writing the image we shrink the main filesystem partition. If the image hasn't automatically resized, make sure to resize the partition so that it takes up the full disk space. To do this: - Insert the SD card into a linux machine or computer, if using an SD card sleeve, make sure it is in writable mode (physical slot switched upwards, towards metal) - If it auto-mounts, unmount it - Open gparted as superuser sudo gparted - Select the volume corresponding to the SD card - Resize the filesystem partition \"rootfs\" so that it fills the remaining disk space (right-click, resize, drag and drop, click green tick box apply all operations ) Stick the card into the Sparrow board's microSD card slot and you're good to go!","title":"Quick start"},{"location":"installing-the-toolchain/","text":"The toolchain is very brittle and will not work if it is installed on a version of Ubuntu that's not supported.","title":"Installing the toolchain"}]}