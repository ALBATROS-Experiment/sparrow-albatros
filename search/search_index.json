{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sparrow Albatros This repository serves three purpouses. The first is to house and version control embedded software that runs on the Sparrow's ARM's processor. The second is to house and version control gateware that runs on the Sparrow's FPGA. The third is to store and checkpoint disk-images of the OS that run the data acquisition software. The embedded software mates with the gateware, so it's conveniant to track them in the same repository. We use git-lfs to track the OS disk-images and exclude them from downloading by default. By tracking disk images here we we can recreate a bit-accurate release of sparrow-albatros without relying on anything outside of this repository. Embedded software We're running Ubunto on the on the Zynq's ARM core. The software that runs on this processor controls. This software can be found in the /software directory. Everything in this repository that runs on the ARM core comes from this directory. Gateware Disk Images","title":"Home"},{"location":"#sparrow-albatros","text":"This repository serves three purpouses. The first is to house and version control embedded software that runs on the Sparrow's ARM's processor. The second is to house and version control gateware that runs on the Sparrow's FPGA. The third is to store and checkpoint disk-images of the OS that run the data acquisition software. The embedded software mates with the gateware, so it's conveniant to track them in the same repository. We use git-lfs to track the OS disk-images and exclude them from downloading by default. By tracking disk images here we we can recreate a bit-accurate release of sparrow-albatros without relying on anything outside of this repository.","title":"Sparrow Albatros"},{"location":"#embedded-software","text":"We're running Ubunto on the on the Zynq's ARM core. The software that runs on this processor controls. This software can be found in the /software directory. Everything in this repository that runs on the ARM core comes from this directory.","title":"Embedded software"},{"location":"#gateware","text":"","title":"Gateware"},{"location":"#disk-images","text":"","title":"Disk Images"},{"location":"data-collection/","text":"Quick start Power and boot the Sparrow system box, connect the ethernet port to your laptop with an ethernet cable (RJ45 connector, you'll need an ethernet port or dongle for your laptop) SSH into the Ubuntu OS running on the Sparrow's ARM core with ssh casper@10.10.11.99 , enter the password, \"casper\", when prompted. The Sparrow's ARM is configured to statically assign it's Eth0 interface to the 10.10.11.99 ipv4 address. If you have trouble with the next two step you may need to configure you're laptop's wired ethernet interface manually to be on the 10.10.xx.xx subnet (subnet mask 255.255.0.0, with an IP address e.g. 10.10.11.55) Mount a hard drive connected over usbA port to this mountpoint: /media/BASEBAND with this command sudo mount /dev/<your HD partition e.g. sda2> /media/BASEBAND . Then run lsblk to identify connected hard drives (Sparrow only supports ext4 formated hard drives). Make sure that the HDD's mounted partition has a /baseband directory. Enter the data acquisition directory using the aliased shortcut daq (you should now have cd'd into /home/casper/sparrow-albatros/software ). Edit the config.ini configuration file to suit your needs. Run the DAQ in sudo by executing sudo ./rundaq.sh . That's it! Checking and troubleshooting Verify that baseband is writing to /media/BASEBAND/baseband , that on-board-correlated data is writing to /home/casper/data_auto_cross , and that logs are writing to /home/casper/logs . If baseband is not writing, open up Wireshark on your laptop and snoop on your wired connection in promiscuous mode. If baseband is dumping correctly you'll be met with a deluge of UDP packets. Look at one of those UDP packets and make sure the UDP payload is not all zeros. You should be weary if there are too many zeros, the data is almost incompressible (i.e. very high entropy). To verify the integrity of your signal, use -X port forwarding and run python livespec.py 0 125 (in the daq directory). In Depth If you're going to modify the code it's good to know how it all sticks together. TODO: everything below here needs to be deleted/adapted to explain what rundaq.sh does instead Now that you've tunneled in, you can run data collection. Find out the name of the drive connected with lsblk , it will probably be sda1 Mount the drive sudo mount /dev/sda1 /media/BASEBAND Navigate to the software directory cd ~/sparrow-albatros/software Modify the user configuration file config.ini to fit your needs Configure the FPGA with python configfpga.py and make sure the switch's lights are flashing consistently. Start a screen session for recording the on board correlations screen -S spec From this screen session run python dump_spectra.py . You may need to run this in sudo in which case make sure to run the correct python interpreter. Find the one activated in the current VM with which python , then copy the result of this and run sudo </path/to/python/interpreter> dump_spectra.py Detach yourself from the screen session with ctrl + a + d Start a new screen session for running the baseband collection script screen -S baseband If you are collecting 4-bit data run python set_optimal_coeffs.py , this uses the on board correlation to optimally set the digital gain coefficients at the requantization stage. [!NOTE] This can only be run at least 15 seconds after the FPGA has been configured (step 5) Compile the c-code that reads UDP packets and writes them to disk with make clean;make Run the c-code with superuser privilages sudo ./dump_baseband Detach yourself from the screen session ctrl + a + d Check that on-board correlations are being written to ~/data_auto_cross and that baseband is being written to /media/BASEBAND/baseband . An easy way to do this is to ls -lh multiple times and watch files grow. Make sure the baseband is sensible (not all zeros or railed) by sniffing the packets and looking at hexdumps of the payloads with Wireshark.","title":"Run the DAQ, collect data"},{"location":"data-collection/#quick-start","text":"Power and boot the Sparrow system box, connect the ethernet port to your laptop with an ethernet cable (RJ45 connector, you'll need an ethernet port or dongle for your laptop) SSH into the Ubuntu OS running on the Sparrow's ARM core with ssh casper@10.10.11.99 , enter the password, \"casper\", when prompted. The Sparrow's ARM is configured to statically assign it's Eth0 interface to the 10.10.11.99 ipv4 address. If you have trouble with the next two step you may need to configure you're laptop's wired ethernet interface manually to be on the 10.10.xx.xx subnet (subnet mask 255.255.0.0, with an IP address e.g. 10.10.11.55) Mount a hard drive connected over usbA port to this mountpoint: /media/BASEBAND with this command sudo mount /dev/<your HD partition e.g. sda2> /media/BASEBAND . Then run lsblk to identify connected hard drives (Sparrow only supports ext4 formated hard drives). Make sure that the HDD's mounted partition has a /baseband directory. Enter the data acquisition directory using the aliased shortcut daq (you should now have cd'd into /home/casper/sparrow-albatros/software ). Edit the config.ini configuration file to suit your needs. Run the DAQ in sudo by executing sudo ./rundaq.sh . That's it!","title":"Quick start"},{"location":"data-collection/#checking-and-troubleshooting","text":"Verify that baseband is writing to /media/BASEBAND/baseband , that on-board-correlated data is writing to /home/casper/data_auto_cross , and that logs are writing to /home/casper/logs . If baseband is not writing, open up Wireshark on your laptop and snoop on your wired connection in promiscuous mode. If baseband is dumping correctly you'll be met with a deluge of UDP packets. Look at one of those UDP packets and make sure the UDP payload is not all zeros. You should be weary if there are too many zeros, the data is almost incompressible (i.e. very high entropy). To verify the integrity of your signal, use -X port forwarding and run python livespec.py 0 125 (in the daq directory).","title":"Checking and troubleshooting"},{"location":"data-collection/#in-depth","text":"If you're going to modify the code it's good to know how it all sticks together. TODO: everything below here needs to be deleted/adapted to explain what rundaq.sh does instead Now that you've tunneled in, you can run data collection. Find out the name of the drive connected with lsblk , it will probably be sda1 Mount the drive sudo mount /dev/sda1 /media/BASEBAND Navigate to the software directory cd ~/sparrow-albatros/software Modify the user configuration file config.ini to fit your needs Configure the FPGA with python configfpga.py and make sure the switch's lights are flashing consistently. Start a screen session for recording the on board correlations screen -S spec From this screen session run python dump_spectra.py . You may need to run this in sudo in which case make sure to run the correct python interpreter. Find the one activated in the current VM with which python , then copy the result of this and run sudo </path/to/python/interpreter> dump_spectra.py Detach yourself from the screen session with ctrl + a + d Start a new screen session for running the baseband collection script screen -S baseband If you are collecting 4-bit data run python set_optimal_coeffs.py , this uses the on board correlation to optimally set the digital gain coefficients at the requantization stage. [!NOTE] This can only be run at least 15 seconds after the FPGA has been configured (step 5) Compile the c-code that reads UDP packets and writes them to disk with make clean;make Run the c-code with superuser privilages sudo ./dump_baseband Detach yourself from the screen session ctrl + a + d Check that on-board correlations are being written to ~/data_auto_cross and that baseband is being written to /media/BASEBAND/baseband . An easy way to do this is to ls -lh multiple times and watch files grow. Make sure the baseband is sensible (not all zeros or railed) by sniffing the packets and looking at hexdumps of the payloads with Wireshark.","title":"In Depth"},{"location":"gateware-compile-synthesize-implement/","text":"","title":"Compile, Synthesize, Implement"},{"location":"gateware-design/","text":"Gateware Design Overview The digital signal processing logic starts at the ADCs, gets PFB'd (Filter + FFT), then splits into two signal paths: The logic re-quantizes the signal to 1 or 4 bits then selects and packages a subset of frequency channels into UDP packets which are streamed out of the Sparrow's 0'th SFP port. On board auto and cross correlations which can be read by the ARM core over SPI. _--> Correlator -> Readable BRAM (SPI) 2x Analog Signal -> ADC -> PFB/FFT _/ \\_--> 1bit quant |mux\\_--> UDP Packets (1GBE) --> 4bit quant | / Foreword on the Simulink-CASPER gateware design paradigm The Simulink (Matlab) and CASPER framework abstracts away the nitty gritty plumbing inherent to modern (2025) FPGA programming in regular text-based HDLs. There are good, bad, and ugly things about this. On the good side, the user can jump right in and design, simulate, compile, implement, and synthesise a basic design targeted for a supported FPGA. The simulation aspect is worth emphasising because it's very easy to write a bug into logic design and it's often very hard to catch it without simulation. On the bad side it is impossible to track small diffs with modern version control tools (git) between two commits because the .slx files, being diagramatic rather than text based, are big and stored in compressed binary format. And the ugly side which is that the toolchain is very brittle and annoying to set up. Once you have the toolchain running and are ready to assemble your first design, you'll notice that there are many different types of color-coded block. The yellow (CASPER) blocks are IO bocks. They map hardware pins to logic, define user programmable BRAMS and registers The green (CASPER) blocks are (vaguely) DSP blocks. They implement logic to manipulate data. The blue Xilinx blocks mix memory access and logic and are provided by Xilinx. These are primitive blocks provided by Xilinx, like operators or primitive data types in C. Some white blocks implement simulation-only logic and tools to help develop and simulate the gateware. The glossy grey blocks are user-defined subsystems that abstract away complexity, like a function in C or Python. Some white blocks also abstract user-defined logic, but these ones have 'mask parameters'. The values of mask parameters are set by the user before compilation, just like C macro-definitions. You can create one by highlighting some logic, righ-clicking, and selecting 'create subsystem from selection'. You can then turn a subsystem into a block with mask parameters by right-clicking the subsystem then Mask > Create Mask. ADC interface The ADC interface block, labelled sparrow_adc , provides the plumbing to link the ADCs' output pins with the design. The sync_adc register provides an interface for the python framework to sync the ADCs. The ADCs are programmed to sample at 250 MSPS but the fabric clock in this design is configured to run at 125 MSPS. To accomplish this clock domain crossing ADC samples are loaded into the fabric two at a time from each Pol (analog channel). The four output pins labels data_a/b_0/1 denote a/b for pol0/1 and 0/1 for first and second samples within one fabric-clock period. PFB FIR The Polyphase Filter Bank Finite Impulse Response stage comprises four (number of inputs) sets of a series of four (number of taps) shift registers. Four frames worth of data from each ADC is windowed (point-wise multiplied by a vector of 'window coefficients'), then stacked and summed vertically. The output of this FIR filter feeds into the FFT. Each frame is 4096 (2^12) samples wide. The sync register is a user-writeable register which creates a 'sync pulse'. The sync pulse serves to align frames output by the PFB FIR filter with all of the logic downstream of it. This digital signal chain comprises an infinite loop of the same operations on consecutive data-frames and the sync pulse tells all the logical operators when the begining and end of each frame is. FFT The FFT block implements a highly optimized Radix-2 decomposition Decimation In Frequency Fast Fourier Transform on parallel inputs. It takes a user-defined shift schedule as input ( pfb_fft_shift ) and records overflow events in a the register named fft_of_count . This FFT implementation takes advantage of the fact that a real-to-complex DFT has half as many outputs as inputs to balance the fact that it's being fed two samples from each ADC simultaneously. It also incorporates a de-scrambler so that the outputs are frequency-ordered complex samples (DIF FFTs naturally scramble their output (frequency domain samples) into bit-reversed order). TODO: inside the FFT TVG1 The first Test Vector Generator follows immediately downstream of the FFT. (The two green bus_create / bus_expand blocks don't modify the data whatsoever but simply package the 36/72 parallel bit-lines together/appart.) A TVG is a simple bit of logic that empowers the user to mux in values from a user-writeable BRAM instead of the input. This module exists can help test and debug gateware both at the simulation stage and in-Silica. The user controls whether to let actual data pass with the enable register, and what data to replace it with by writing to the data BRAM. Requantization After the TVG the signal is split three ways. The first two requantize the same complex digital signal--in parallel--to 1+1-bit and 4+4-bits respectively. (Each of the real and imaginary components of each sample is quantized to 1 or 4 bits.) Data re-ordering and bussifying follows both one-bit and four-bit requantization stages. The output order is defined by the user so that the frequency channels to be packetized come out first. Both 1bit and 4bit data is 'bussified' onto an 8-bit bus. 8-bits is not wide enough for the 4-bit data (4 bits ADC0 real + 4 bits ADC0 imaginary + 4 bits ADC1 real + 4 bits ADC1 imaginary = 16 bits per clock), which is why the re-order stage must come before the bussifying stage. This limits the number of selectable channels to 1024 of 2048. The one bit re-quantization logic is just a bunch of comparators (> or <). In parallel we quantize each component (real/imaginary) of each frequency channel to four bits. To exploit the full range of bits excersised by 4-bit quantization we apply digital gain to each frequency channel individually. The gain in each channel is set by the user through the coeffs_pol0 / coeffs_pol1 registers. The result is saturated against a floor and ceiling of the 4-bit range (-/+0.875) to wrapping (overflow). This image shows the logic for one of four quantization signal paths is shown. Packetiser The packetiser TODO: explaim more TODO: actual wavedrom diagram, below is dummy { \"signal\": [ {\"name\": \"clk\", \"wave\": \"p.....|...\"}, {\"name\": \"dat\", \"wave\": \"x.345x|=.x\", \"data\": [\"head\", \"body\", \"tail\", \"data\"]}, {\"name\": \"req\", \"wave\": \"0.1..0|1.0\"}, {}, {\"name\": \"ack\", \"wave\": \"1.....|01.\"} ] } blah blih blough Lorum Ipsum Comunitatus Once the data has been packetized, it goes into the one_gbe block, and the CASPER framework takes care of the plumbing to pipe this into the correct Xilinx IP that implements UDP packetizing, and routs it to the correct physical SFP port (SFP0). In the image, a helpful user-readable buffer-overflow counter tx_of_cnt keeps track of overflowing packets, and the signal coming out of our user-defined packetizer also routs in simulation only to a virtual oscilascope. On-board correlator The signal path branches after the FFT. In the previous section we looked at re-quantization, data selection, and UDP packetizing, here we look at the second branch down-stream of the FFT: the on board correlator (OBC). The OBC computes the auto and cross correlations of the two digital signals it has access to. The power in each pol is computed with a simple accumulator. Real and imaginary components of the cross correlation are similarly calculated. The result is dumped periodically into addressable BRAM registers pol00 , pol11 , pol01r , pol01i . Correlator accumulator book-keeping It's important to do some book-keeping to make sure the correlator BRAMs won't overflow. If the signal is U37_36 and the accumulator BRAM is U64_35 then we can only accumulate 2^28 samples samples (per channel), in seconds the accumulator BRAM fills up in 2^28*4096/250e6 = 4398 seconds, which is over an hour. We will never want to accumulate more than a few seconds. However, the calculus changes if we implement FFT bit-growth to avoid doing a full shift schedule. If we grow the data by one bit on every FFT butterfly stage we're eating up 12 bits, which means that it becomes logically possible for the accumulator BRAMs to overflow after only one second, which is unacceptable. This means we either have to grow our BRAMs or do something to reduce the bit depth of these numbers. User read/writeable registers We make use of all named addressable registers in this design so it's worth knowing what each of them does. (The left-pointing pentagonal tags mean goto and are paired with right-pointing ones of the same name.) - gbe_en GigaBit Ethernet interface ENable. Single bit, 0 for disable, 1 for enable. - gbe_rst GigaBit Ethernet interface ReSeT. Single bit. Resets on transition from 0 to 1. - pack_rst PACKetizer ReSeT. Single bit to reset packetizer logic, including spectrum counter, on transition from 0 to 1. - cnt_rst accumulator CoNTroller ReSeT. Single bit to reset accumulator control logic. - acc_len ACCumulation LENgth. UFix32 sets the number of spectra to accumulate for each correlation. (How long to integrate data, if you prefer to think that way.) This number times 4096/250e6 gives the accumulation time in seconds. - dest_ip Sets the DESTination IP addresss. - dest_prt Sets the DESTination PoRT. - sync_cnt (read only) does exactly nothing because I removed the logic that periodically syncs all the logic. Instead it just syncs stuff once on initialization. - acc_cnt (read_only) ACCumulation CouNTer. Counts the number of spectra that have been accumulated. Other user read/writeable registers are scattered throughout the design. sync_adc SYNChronize ADC logic. Single bit pulse active on transition from 0 to 1. sync Creates SYNChronizing pulse that aligns each set of the DSP chain. Single bit pulse, active on transition from 0 to 1. pfb_fft_shift UFix12 determines the shift schedule. Each bit represents 0 for no shift, 1 for shift. Currently we have a full shift schedule. We may want to implement a bit-growth FFT so that we can have our cake (low noise floor from not shifting) and eat it too (no FFT overflows). fft_of_count (read only) FFT OverFlow COUNTer. Every time there's an overflow event in a frame +1 is added to this UFix32 register. sel SELects which requantization bit mode to choose from: 0 for 1bit, 1 for 4bits. tvg1_enable Enables the the TVG right after the FFT stage. 0 to pass actual data, 1 to pass values read sequentially from the BRAM labelled data . tvg16bit_enable Enables the the TVG right after the 4bit requantization stage. 0 to pass actual data, 1 to pass values read sequentially from the BRAM labelled data . four_bit_quant_clip_count TODO spectra_per_packet TODO bytes_per_spectrum TODO tx_of_cnt TODO User BRAM interfaces tvg1_data TODO tvg16bit_data TODO four_bit_quant_coeffs_pol0/1 TODO one_bit_reorder_map1 TODO four_bit_reorder_map1 TODO pol00 , pol11 , pol01r , pol01i TODO","title":"Design Overview"},{"location":"gateware-design/#gateware-design-overview","text":"The digital signal processing logic starts at the ADCs, gets PFB'd (Filter + FFT), then splits into two signal paths: The logic re-quantizes the signal to 1 or 4 bits then selects and packages a subset of frequency channels into UDP packets which are streamed out of the Sparrow's 0'th SFP port. On board auto and cross correlations which can be read by the ARM core over SPI. _--> Correlator -> Readable BRAM (SPI) 2x Analog Signal -> ADC -> PFB/FFT _/ \\_--> 1bit quant |mux\\_--> UDP Packets (1GBE) --> 4bit quant | /","title":"Gateware Design Overview"},{"location":"gateware-design/#foreword-on-the-simulink-casper-gateware-design-paradigm","text":"The Simulink (Matlab) and CASPER framework abstracts away the nitty gritty plumbing inherent to modern (2025) FPGA programming in regular text-based HDLs. There are good, bad, and ugly things about this. On the good side, the user can jump right in and design, simulate, compile, implement, and synthesise a basic design targeted for a supported FPGA. The simulation aspect is worth emphasising because it's very easy to write a bug into logic design and it's often very hard to catch it without simulation. On the bad side it is impossible to track small diffs with modern version control tools (git) between two commits because the .slx files, being diagramatic rather than text based, are big and stored in compressed binary format. And the ugly side which is that the toolchain is very brittle and annoying to set up. Once you have the toolchain running and are ready to assemble your first design, you'll notice that there are many different types of color-coded block. The yellow (CASPER) blocks are IO bocks. They map hardware pins to logic, define user programmable BRAMS and registers The green (CASPER) blocks are (vaguely) DSP blocks. They implement logic to manipulate data. The blue Xilinx blocks mix memory access and logic and are provided by Xilinx. These are primitive blocks provided by Xilinx, like operators or primitive data types in C. Some white blocks implement simulation-only logic and tools to help develop and simulate the gateware. The glossy grey blocks are user-defined subsystems that abstract away complexity, like a function in C or Python. Some white blocks also abstract user-defined logic, but these ones have 'mask parameters'. The values of mask parameters are set by the user before compilation, just like C macro-definitions. You can create one by highlighting some logic, righ-clicking, and selecting 'create subsystem from selection'. You can then turn a subsystem into a block with mask parameters by right-clicking the subsystem then Mask > Create Mask.","title":"Foreword on the Simulink-CASPER gateware design paradigm"},{"location":"gateware-design/#adc-interface","text":"The ADC interface block, labelled sparrow_adc , provides the plumbing to link the ADCs' output pins with the design. The sync_adc register provides an interface for the python framework to sync the ADCs. The ADCs are programmed to sample at 250 MSPS but the fabric clock in this design is configured to run at 125 MSPS. To accomplish this clock domain crossing ADC samples are loaded into the fabric two at a time from each Pol (analog channel). The four output pins labels data_a/b_0/1 denote a/b for pol0/1 and 0/1 for first and second samples within one fabric-clock period.","title":"ADC interface"},{"location":"gateware-design/#pfb-fir","text":"The Polyphase Filter Bank Finite Impulse Response stage comprises four (number of inputs) sets of a series of four (number of taps) shift registers. Four frames worth of data from each ADC is windowed (point-wise multiplied by a vector of 'window coefficients'), then stacked and summed vertically. The output of this FIR filter feeds into the FFT. Each frame is 4096 (2^12) samples wide. The sync register is a user-writeable register which creates a 'sync pulse'. The sync pulse serves to align frames output by the PFB FIR filter with all of the logic downstream of it. This digital signal chain comprises an infinite loop of the same operations on consecutive data-frames and the sync pulse tells all the logical operators when the begining and end of each frame is.","title":"PFB FIR"},{"location":"gateware-design/#fft","text":"The FFT block implements a highly optimized Radix-2 decomposition Decimation In Frequency Fast Fourier Transform on parallel inputs. It takes a user-defined shift schedule as input ( pfb_fft_shift ) and records overflow events in a the register named fft_of_count . This FFT implementation takes advantage of the fact that a real-to-complex DFT has half as many outputs as inputs to balance the fact that it's being fed two samples from each ADC simultaneously. It also incorporates a de-scrambler so that the outputs are frequency-ordered complex samples (DIF FFTs naturally scramble their output (frequency domain samples) into bit-reversed order). TODO: inside the FFT","title":"FFT"},{"location":"gateware-design/#tvg1","text":"The first Test Vector Generator follows immediately downstream of the FFT. (The two green bus_create / bus_expand blocks don't modify the data whatsoever but simply package the 36/72 parallel bit-lines together/appart.) A TVG is a simple bit of logic that empowers the user to mux in values from a user-writeable BRAM instead of the input. This module exists can help test and debug gateware both at the simulation stage and in-Silica. The user controls whether to let actual data pass with the enable register, and what data to replace it with by writing to the data BRAM.","title":"TVG1"},{"location":"gateware-design/#requantization","text":"After the TVG the signal is split three ways. The first two requantize the same complex digital signal--in parallel--to 1+1-bit and 4+4-bits respectively. (Each of the real and imaginary components of each sample is quantized to 1 or 4 bits.) Data re-ordering and bussifying follows both one-bit and four-bit requantization stages. The output order is defined by the user so that the frequency channels to be packetized come out first. Both 1bit and 4bit data is 'bussified' onto an 8-bit bus. 8-bits is not wide enough for the 4-bit data (4 bits ADC0 real + 4 bits ADC0 imaginary + 4 bits ADC1 real + 4 bits ADC1 imaginary = 16 bits per clock), which is why the re-order stage must come before the bussifying stage. This limits the number of selectable channels to 1024 of 2048. The one bit re-quantization logic is just a bunch of comparators (> or <). In parallel we quantize each component (real/imaginary) of each frequency channel to four bits. To exploit the full range of bits excersised by 4-bit quantization we apply digital gain to each frequency channel individually. The gain in each channel is set by the user through the coeffs_pol0 / coeffs_pol1 registers. The result is saturated against a floor and ceiling of the 4-bit range (-/+0.875) to wrapping (overflow). This image shows the logic for one of four quantization signal paths is shown.","title":"Requantization"},{"location":"gateware-design/#packetiser","text":"The packetiser TODO: explaim more TODO: actual wavedrom diagram, below is dummy { \"signal\": [ {\"name\": \"clk\", \"wave\": \"p.....|...\"}, {\"name\": \"dat\", \"wave\": \"x.345x|=.x\", \"data\": [\"head\", \"body\", \"tail\", \"data\"]}, {\"name\": \"req\", \"wave\": \"0.1..0|1.0\"}, {}, {\"name\": \"ack\", \"wave\": \"1.....|01.\"} ] } blah blih blough Lorum Ipsum Comunitatus Once the data has been packetized, it goes into the one_gbe block, and the CASPER framework takes care of the plumbing to pipe this into the correct Xilinx IP that implements UDP packetizing, and routs it to the correct physical SFP port (SFP0). In the image, a helpful user-readable buffer-overflow counter tx_of_cnt keeps track of overflowing packets, and the signal coming out of our user-defined packetizer also routs in simulation only to a virtual oscilascope.","title":"Packetiser"},{"location":"gateware-design/#on-board-correlator","text":"The signal path branches after the FFT. In the previous section we looked at re-quantization, data selection, and UDP packetizing, here we look at the second branch down-stream of the FFT: the on board correlator (OBC). The OBC computes the auto and cross correlations of the two digital signals it has access to. The power in each pol is computed with a simple accumulator. Real and imaginary components of the cross correlation are similarly calculated. The result is dumped periodically into addressable BRAM registers pol00 , pol11 , pol01r , pol01i .","title":"On-board correlator"},{"location":"gateware-design/#correlator-accumulator-book-keeping","text":"It's important to do some book-keeping to make sure the correlator BRAMs won't overflow. If the signal is U37_36 and the accumulator BRAM is U64_35 then we can only accumulate 2^28 samples samples (per channel), in seconds the accumulator BRAM fills up in 2^28*4096/250e6 = 4398 seconds, which is over an hour. We will never want to accumulate more than a few seconds. However, the calculus changes if we implement FFT bit-growth to avoid doing a full shift schedule. If we grow the data by one bit on every FFT butterfly stage we're eating up 12 bits, which means that it becomes logically possible for the accumulator BRAMs to overflow after only one second, which is unacceptable. This means we either have to grow our BRAMs or do something to reduce the bit depth of these numbers.","title":"Correlator accumulator book-keeping"},{"location":"gateware-design/#user-readwriteable-registers","text":"We make use of all named addressable registers in this design so it's worth knowing what each of them does. (The left-pointing pentagonal tags mean goto and are paired with right-pointing ones of the same name.) - gbe_en GigaBit Ethernet interface ENable. Single bit, 0 for disable, 1 for enable. - gbe_rst GigaBit Ethernet interface ReSeT. Single bit. Resets on transition from 0 to 1. - pack_rst PACKetizer ReSeT. Single bit to reset packetizer logic, including spectrum counter, on transition from 0 to 1. - cnt_rst accumulator CoNTroller ReSeT. Single bit to reset accumulator control logic. - acc_len ACCumulation LENgth. UFix32 sets the number of spectra to accumulate for each correlation. (How long to integrate data, if you prefer to think that way.) This number times 4096/250e6 gives the accumulation time in seconds. - dest_ip Sets the DESTination IP addresss. - dest_prt Sets the DESTination PoRT. - sync_cnt (read only) does exactly nothing because I removed the logic that periodically syncs all the logic. Instead it just syncs stuff once on initialization. - acc_cnt (read_only) ACCumulation CouNTer. Counts the number of spectra that have been accumulated. Other user read/writeable registers are scattered throughout the design. sync_adc SYNChronize ADC logic. Single bit pulse active on transition from 0 to 1. sync Creates SYNChronizing pulse that aligns each set of the DSP chain. Single bit pulse, active on transition from 0 to 1. pfb_fft_shift UFix12 determines the shift schedule. Each bit represents 0 for no shift, 1 for shift. Currently we have a full shift schedule. We may want to implement a bit-growth FFT so that we can have our cake (low noise floor from not shifting) and eat it too (no FFT overflows). fft_of_count (read only) FFT OverFlow COUNTer. Every time there's an overflow event in a frame +1 is added to this UFix32 register. sel SELects which requantization bit mode to choose from: 0 for 1bit, 1 for 4bits. tvg1_enable Enables the the TVG right after the FFT stage. 0 to pass actual data, 1 to pass values read sequentially from the BRAM labelled data . tvg16bit_enable Enables the the TVG right after the 4bit requantization stage. 0 to pass actual data, 1 to pass values read sequentially from the BRAM labelled data . four_bit_quant_clip_count TODO spectra_per_packet TODO bytes_per_spectrum TODO tx_of_cnt TODO","title":"User read/writeable registers"},{"location":"gateware-design/#user-bram-interfaces","text":"tvg1_data TODO tvg16bit_data TODO four_bit_quant_coeffs_pol0/1 TODO one_bit_reorder_map1 TODO four_bit_reorder_map1 TODO pol00 , pol11 , pol01r , pol01i TODO","title":"User BRAM interfaces"},{"location":"gateware-modify-simulate/","text":"Once you've got the toolchain up and running on a beefy computer... Modify the design matlab... Synthesize and Implement the design lorum ipsum compiliation (mlab - hdl) > synthesis (hdl - logic) > implementation (logic - hardware) Open up the synthesized design in Vivado and check timing","title":"Modify and Simulate"},{"location":"gateware-modify-simulate/#modify-the-design","text":"matlab...","title":"Modify the design"},{"location":"gateware-modify-simulate/#synthesize-and-implement-the-design","text":"lorum ipsum compiliation (mlab - hdl) > synthesis (hdl - logic) > implementation (logic - hardware) Open up the synthesized design in Vivado and check timing","title":"Synthesize and Implement the design"},{"location":"installing-sparrow-albatros/","text":"We're running Ubuntu 18.04.6 LTS (Bionic Beaver) on the Sparrow's ARM processor. Quick start You have all the hardware for a Sparrow-Albatros data acquisition system and you want to get the software up and running for data collection. Easy, just download the latest image from os-sd-images directory , unzip it, and write it onto a fresh SD card. To save time writing the image we shrink the main filesystem partition. If the image hasn't automatically resized, make sure to resize the partition so that it takes up the full disk space. To do this: Insert the SD card into a linux machine or computer, if using an SD card sleeve, make sure it is in writable mode (physical slot switched upwards, towards metal) If it auto-mounts, unmount it Open gparted as superuser sudo gparted Select the volume corresponding to the SD card Resize the filesystem partition \"rootfs\" so that it fills the remaining disk space (right-click, resize, drag and drop, click green tick box apply all operations ) Stick the card into the Sparrow board's microSD card slot and you're good to go! Installing Sparrow-Albatros software onto a fresh SD card If you want to install and this software on a different OS, here are a few things to look out for: When cloning the repository, make sure to not pull large files. If git-lfs is installed cloning will by default pull large files from the repository. To avoid pulling large files execute export GIT_LFS_SKIP_SMUDGE=1 then git clone --filter=blob:none https://github.com/ALBATROS-Experiment/sparrow-albatros You need to install realtimeradio 's sparrow-fpga repository and configure the zync_scripts/onboot.sh script to run on boot. In our imaged setup the onboot script is symlinked to the user's root directory and executes automatically on each boot. The onboot.sh script sets some environment variables and configures the PLL. For the LEO Bodnar GPS module to work, copy software/10-local.rules to /etc/udev/rules.d/ . Then reboot or reload the udevadm with sudo udevadm control --reload , sudo udevadm trigger . Check that it's working by running the software/check_lb.py script as superuser . For to set up a reverse tunnel on boot you need to make a service. You can follow the example of the service at /etc/systemd/system/reverse-tunnel-service-tb-stephenfay.service which sets up a reverse tunnel to my twiddlebug user on boot. Reverse tunnel service reverse-tunnel-service-tb-stephenfay.service [Unit] Description=Reverse SSH tunnel After=network-online.target Wants=network-online.target [Service] ExecStart=/usr/bin/ssh -N -R 18997:localhost:22 -p 2690 -i /home/casper/.ssh/id_rsa_sparrow_tb -o StrictHostKeyChecking=no -o ServerAliveInterval=60 -o ExitOnForwardFailure=yes stephenfay@132.206.126.20 RestartSec=30 Restart=always User=casper [Install] WantedBy=multi-user.target","title":"Installing Sparrow Albatros"},{"location":"installing-sparrow-albatros/#quick-start","text":"You have all the hardware for a Sparrow-Albatros data acquisition system and you want to get the software up and running for data collection. Easy, just download the latest image from os-sd-images directory , unzip it, and write it onto a fresh SD card. To save time writing the image we shrink the main filesystem partition. If the image hasn't automatically resized, make sure to resize the partition so that it takes up the full disk space. To do this: Insert the SD card into a linux machine or computer, if using an SD card sleeve, make sure it is in writable mode (physical slot switched upwards, towards metal) If it auto-mounts, unmount it Open gparted as superuser sudo gparted Select the volume corresponding to the SD card Resize the filesystem partition \"rootfs\" so that it fills the remaining disk space (right-click, resize, drag and drop, click green tick box apply all operations ) Stick the card into the Sparrow board's microSD card slot and you're good to go!","title":"Quick start"},{"location":"installing-sparrow-albatros/#installing-sparrow-albatros-software-onto-a-fresh-sd-card","text":"If you want to install and this software on a different OS, here are a few things to look out for: When cloning the repository, make sure to not pull large files. If git-lfs is installed cloning will by default pull large files from the repository. To avoid pulling large files execute export GIT_LFS_SKIP_SMUDGE=1 then git clone --filter=blob:none https://github.com/ALBATROS-Experiment/sparrow-albatros You need to install realtimeradio 's sparrow-fpga repository and configure the zync_scripts/onboot.sh script to run on boot. In our imaged setup the onboot script is symlinked to the user's root directory and executes automatically on each boot. The onboot.sh script sets some environment variables and configures the PLL. For the LEO Bodnar GPS module to work, copy software/10-local.rules to /etc/udev/rules.d/ . Then reboot or reload the udevadm with sudo udevadm control --reload , sudo udevadm trigger . Check that it's working by running the software/check_lb.py script as superuser . For to set up a reverse tunnel on boot you need to make a service. You can follow the example of the service at /etc/systemd/system/reverse-tunnel-service-tb-stephenfay.service which sets up a reverse tunnel to my twiddlebug user on boot. Reverse tunnel service reverse-tunnel-service-tb-stephenfay.service [Unit] Description=Reverse SSH tunnel After=network-online.target Wants=network-online.target [Service] ExecStart=/usr/bin/ssh -N -R 18997:localhost:22 -p 2690 -i /home/casper/.ssh/id_rsa_sparrow_tb -o StrictHostKeyChecking=no -o ServerAliveInterval=60 -o ExitOnForwardFailure=yes stephenfay@132.206.126.20 RestartSec=30 Restart=always User=casper [Install] WantedBy=multi-user.target","title":"Installing Sparrow-Albatros software onto a fresh SD card"},{"location":"installing-the-toolchain/","text":"The toolchain is very brittle and will not work if it is installed on a version of Ubuntu that's not supported.","title":"Installing the Toolchain"},{"location":"tuning-the-gateware/","text":"Tuning the Gateware from Python The Design Overview section documents how the gateware is designed diagramatically in Matlab at a high level of abstraction. If you are unfamiliar with gateware design or are finding this section confusing you may want to read that section before this one. Reading and Writing to Programmable Registers In Python the CasperFpga class allows you to interface with named FPGA registers. The gateware needs to be tuned and configured according to the user's needs, such as which channels to pick and which what bit mode to select. This configuration happens in five steps. Setup. TODO Set the channel order. Re-order the frequency channels so that the UDP payload packetizer selects the correct channels. For example, to select only channels 120:136 you must re-order the channels so that 120:136 occur at the beginning of each frame. For deeper explanation of why we need to do this see the packetizer section . Optionally set the 4 bit coefficients. Tune. TODO Optionally update the 4 bit coefficients based on OBC data. TODO Setup sparrow_albatros . AlbatrosDigitizer . setup () Source code in software/sparrow_albatros.py 192 193 194 195 196 197 198 def setup ( self ): self . logger . info ( \"Programming FPGA\" ) self . program_fpga () fpga_clock_mhz = self . cfpga . estimate_fpga_clock () self . logger . info ( f \"Estimated FPGA clock is { fpga_clock_mhz : .2f } \" ) self . logger . info ( \"Initializing ADCs\" ) self . initialize_adc () Set channel order sparrow_albatros . AlbatrosDigitizer . set_channel_order ( channels , bits ) Sets the firmware channels Source code in software/sparrow_albatros.py 154 155 156 157 158 159 160 def set_channel_order ( self , channels , bits ): \"\"\"Sets the firmware channels\"\"\" # hard coded names of brams if bits == 1 : channel_map = \"one_bit_reorder_map1\" elif bits == 4 : channel_map = \"four_bit_reorder_map1\" else : raise ValueError ( f \"Bits must be 1 or 4, not { bits } \" ) self . cfpga . write ( channel_map , channels . astype ( \">H\" ) . tobytes (), offset = 0 ) Tune sparrow_albatros . AlbatrosDigitizer . tune ( ref_clock , fftshift , acc_len , dest_ip , dest_prt , spectra_per_packet , bytes_per_spectrum , bits , dest_mac = 0 ) This method \"tunes\" the FPGA Gateware's input registers to suit the user's needs. Assumes fpga has been programmed and cfpga is running. Sets values in FPGA's programmable Registers and BRAMs. Basic sanity checks of FPGA output values, e.g. FFT overflows. Parameters: ref_clock ( float ) \u2013 Reference clock in MHz fftshift ( int ) \u2013 FFT shift schedule. This int is re-interpreted as a sequence of bits, the 12 LSBs are used to define the shift schedule. Do 1/0 for on/off.* acc_len ( int ) \u2013 Number of spectra accumulated to integrate correlations.* dest_ip ( str ) \u2013 IP address to send packets to. The input is an IPV4 string following the convention \"x.x.x.x\", e.g. \"192.168.0.1\". This IP address is reinterpreted as an int and that value is written to a register on the FPGA. dest_prt ( int ) \u2013 Destination port number.* spectra_per_packet ( int ) \u2013 Number of spectra to include in each UDP packet.* bytes_per_spectrum ( int ) \u2013 Number of bytes in one quantized spectrum.* bits ( int ) \u2013 Number of bits per real/imaginary componant after requantization. Takes values 1 or 4. dest_mac ( int , default: 0 ) \u2013 Not yet implemented. Configure the destination MAC address. * This parameter's value gets written to a register on the FPGA. Source code in software/sparrow_albatros.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 def tune ( self , ref_clock , fftshift , acc_len , dest_ip , dest_prt , spectra_per_packet , bytes_per_spectrum , bits , dest_mac : int = 0 ): \"\"\" This method \"tunes\" the FPGA Gateware's input registers to suit the user's needs. - Assumes fpga has been programmed and cfpga is running. - Sets values in FPGA's programmable Registers and BRAMs. - Basic sanity checks of FPGA output values, e.g. FFT overflows. Args: ref_clock (float): Reference clock in MHz fftshift (int): FFT shift schedule. This int is re-interpreted as a sequence of bits, the 12 LSBs are used to define the shift schedule. Do 1/0 for on/off.\\* acc_len (int): Number of spectra accumulated to integrate correlations.\\* dest_ip (str): IP address to send packets to. The input is an IPV4 string following the convention \"x.x.x.x\", e.g. \"192.168.0.1\". This IP address is reinterpreted as an int and that value is written to a register on the FPGA. dest_prt (int): Destination port number.\\* spectra_per_packet (int): Number of spectra to include in each UDP packet.\\* bytes_per_spectrum (int): Number of bytes in one quantized spectrum.\\* bits (int): Number of bits per real/imaginary componant after requantization. Takes values 1 or 4. dest_mac (int): *Not yet implemented.* Configure the destination MAC address. \\* This parameter's value gets written to a register on the FPGA. \"\"\" MTU = 1500 # max number of bytes in a packet assert spectra_per_packet < ( 1 << 5 ), \"spec-per-pack too large for slice, aborting\" assert spectra_per_packet * bytes_per_spectrum <= MTU - 8 , \"Packets too large, will cause fragmentation\" assert bits in ( 1 , 4 ), f \"Baseband requantization mode must be 1 or 4, not { bits } \" # Assume bitstream already uploaded, data in self.cfpga # Assume ADCs already initialized including that get_system_information... # Inherit adc's logger level self . adc . ref = ref_clock # Set reference clock for ADC # ADC calibration assumed already aligned (?) # Need to set the ADC gain? # Get info from and set registers self . logger . info ( f \"FPGA clock: { self . cfpga . estimate_fpga_clock () : .2f } \" ) self . logger . info ( f \"Set FFT shift schedule to { fftshift : b } \" ) self . cfpga . registers . pfb_fft_shift . write_int ( fftshift ) self . logger . info ( f \"Set correlator accumulation length to { acc_len } \" ) self . cfpga . registers . acc_len . write_int ( acc_len ) self . logger . info ( \"Reset GBE (UDP packetizer)\" ) self . cfpga . registers . gbe_rst . write_int ( 1 ) self . cfpga . registers . gbe_en . write_int ( 0 ) self . logger . info ( f \"Set spectra-per-packet to { spectra_per_packet } \" ) self . cfpga . registers . packetiser_spectra_per_packet . write_int ( spectra_per_packet ) self . logger . info ( f \"Set bytes-per-spectrum to { bytes_per_spectrum } \" ) self . cfpga . registers . packetiser_bytes_per_spectrum . write_int ( bytes_per_spectrum ) self . logger . info ( f \"Set quantization bit mode to { bits } -bits\" ) if bits == 1 : self . cfpga . registers . sel . write_int ( 0 ) elif bits == 4 : self . cfpga . registers . sel . write_int ( 1 ) self . logger . info ( f \"NOT YET IMPLEMENTED: Setting destination MAC address to { dest_mac } \" ) # TODO: set destination MAC address self . logger . info ( f \"Set destination IP address and port to { dest_ip } : { dest_prt } \" ) self . cfpga . registers . dest_ip . write_int ( str2ip ( dest_ip )) self . cfpga . registers . dest_prt . write_int ( dest_prt ) # Do we need to set mac address? #time.sleep(1.1) # dogmatically wait for regs to set before sending sync pulse self . sync_pulse () fft_of_count = self . cfpga . registers . fft_of_count . read_uint () if fft_of_count != 0 : self . logger . warning ( f \"FFT overflowing: count= { fft_of_count } \" ) else : self . logger . info ( f \"No FFT overflows detected\" ) self . logger . info ( \"Enabling 1 GbE output\" ) self . cfpga . registers . gbe_en . write_int ( 1 ) #self.logger.info(\"Leaving GBE reset high; pull it down manually once you think the negotiation has happened well!\") self . cfpga . registers . gbe_rst . write_int ( 0 ) gbe_overflow = self . cfpga . registers . tx_of_cnt . read_uint () if gbe_overflow : self . logger . warning ( f \"GbE transmit overflowing: count= { gbe_overflow } \" ) else : self . logger . info ( \"No GbE overflows detected\" ) self . logger . info ( \"Setup and tuning complete\" ) return The communication stack You may be wondering how Python is able to read from and write to FPGA registers.","title":"Tuning the gateware"},{"location":"tuning-the-gateware/#tuning-the-gateware-from-python","text":"The Design Overview section documents how the gateware is designed diagramatically in Matlab at a high level of abstraction. If you are unfamiliar with gateware design or are finding this section confusing you may want to read that section before this one.","title":"Tuning the Gateware from Python"},{"location":"tuning-the-gateware/#reading-and-writing-to-programmable-registers","text":"In Python the CasperFpga class allows you to interface with named FPGA registers. The gateware needs to be tuned and configured according to the user's needs, such as which channels to pick and which what bit mode to select. This configuration happens in five steps. Setup. TODO Set the channel order. Re-order the frequency channels so that the UDP payload packetizer selects the correct channels. For example, to select only channels 120:136 you must re-order the channels so that 120:136 occur at the beginning of each frame. For deeper explanation of why we need to do this see the packetizer section . Optionally set the 4 bit coefficients. Tune. TODO Optionally update the 4 bit coefficients based on OBC data. TODO","title":"Reading and Writing to Programmable Registers"},{"location":"tuning-the-gateware/#setup","text":"","title":"Setup"},{"location":"tuning-the-gateware/#sparrow_albatros.AlbatrosDigitizer.setup","text":"Source code in software/sparrow_albatros.py 192 193 194 195 196 197 198 def setup ( self ): self . logger . info ( \"Programming FPGA\" ) self . program_fpga () fpga_clock_mhz = self . cfpga . estimate_fpga_clock () self . logger . info ( f \"Estimated FPGA clock is { fpga_clock_mhz : .2f } \" ) self . logger . info ( \"Initializing ADCs\" ) self . initialize_adc ()","title":"setup"},{"location":"tuning-the-gateware/#set-channel-order","text":"","title":"Set channel order"},{"location":"tuning-the-gateware/#sparrow_albatros.AlbatrosDigitizer.set_channel_order","text":"Sets the firmware channels Source code in software/sparrow_albatros.py 154 155 156 157 158 159 160 def set_channel_order ( self , channels , bits ): \"\"\"Sets the firmware channels\"\"\" # hard coded names of brams if bits == 1 : channel_map = \"one_bit_reorder_map1\" elif bits == 4 : channel_map = \"four_bit_reorder_map1\" else : raise ValueError ( f \"Bits must be 1 or 4, not { bits } \" ) self . cfpga . write ( channel_map , channels . astype ( \">H\" ) . tobytes (), offset = 0 )","title":"set_channel_order"},{"location":"tuning-the-gateware/#tune","text":"","title":"Tune"},{"location":"tuning-the-gateware/#sparrow_albatros.AlbatrosDigitizer.tune","text":"This method \"tunes\" the FPGA Gateware's input registers to suit the user's needs. Assumes fpga has been programmed and cfpga is running. Sets values in FPGA's programmable Registers and BRAMs. Basic sanity checks of FPGA output values, e.g. FFT overflows. Parameters: ref_clock ( float ) \u2013 Reference clock in MHz fftshift ( int ) \u2013 FFT shift schedule. This int is re-interpreted as a sequence of bits, the 12 LSBs are used to define the shift schedule. Do 1/0 for on/off.* acc_len ( int ) \u2013 Number of spectra accumulated to integrate correlations.* dest_ip ( str ) \u2013 IP address to send packets to. The input is an IPV4 string following the convention \"x.x.x.x\", e.g. \"192.168.0.1\". This IP address is reinterpreted as an int and that value is written to a register on the FPGA. dest_prt ( int ) \u2013 Destination port number.* spectra_per_packet ( int ) \u2013 Number of spectra to include in each UDP packet.* bytes_per_spectrum ( int ) \u2013 Number of bytes in one quantized spectrum.* bits ( int ) \u2013 Number of bits per real/imaginary componant after requantization. Takes values 1 or 4. dest_mac ( int , default: 0 ) \u2013 Not yet implemented. Configure the destination MAC address. * This parameter's value gets written to a register on the FPGA. Source code in software/sparrow_albatros.py 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 def tune ( self , ref_clock , fftshift , acc_len , dest_ip , dest_prt , spectra_per_packet , bytes_per_spectrum , bits , dest_mac : int = 0 ): \"\"\" This method \"tunes\" the FPGA Gateware's input registers to suit the user's needs. - Assumes fpga has been programmed and cfpga is running. - Sets values in FPGA's programmable Registers and BRAMs. - Basic sanity checks of FPGA output values, e.g. FFT overflows. Args: ref_clock (float): Reference clock in MHz fftshift (int): FFT shift schedule. This int is re-interpreted as a sequence of bits, the 12 LSBs are used to define the shift schedule. Do 1/0 for on/off.\\* acc_len (int): Number of spectra accumulated to integrate correlations.\\* dest_ip (str): IP address to send packets to. The input is an IPV4 string following the convention \"x.x.x.x\", e.g. \"192.168.0.1\". This IP address is reinterpreted as an int and that value is written to a register on the FPGA. dest_prt (int): Destination port number.\\* spectra_per_packet (int): Number of spectra to include in each UDP packet.\\* bytes_per_spectrum (int): Number of bytes in one quantized spectrum.\\* bits (int): Number of bits per real/imaginary componant after requantization. Takes values 1 or 4. dest_mac (int): *Not yet implemented.* Configure the destination MAC address. \\* This parameter's value gets written to a register on the FPGA. \"\"\" MTU = 1500 # max number of bytes in a packet assert spectra_per_packet < ( 1 << 5 ), \"spec-per-pack too large for slice, aborting\" assert spectra_per_packet * bytes_per_spectrum <= MTU - 8 , \"Packets too large, will cause fragmentation\" assert bits in ( 1 , 4 ), f \"Baseband requantization mode must be 1 or 4, not { bits } \" # Assume bitstream already uploaded, data in self.cfpga # Assume ADCs already initialized including that get_system_information... # Inherit adc's logger level self . adc . ref = ref_clock # Set reference clock for ADC # ADC calibration assumed already aligned (?) # Need to set the ADC gain? # Get info from and set registers self . logger . info ( f \"FPGA clock: { self . cfpga . estimate_fpga_clock () : .2f } \" ) self . logger . info ( f \"Set FFT shift schedule to { fftshift : b } \" ) self . cfpga . registers . pfb_fft_shift . write_int ( fftshift ) self . logger . info ( f \"Set correlator accumulation length to { acc_len } \" ) self . cfpga . registers . acc_len . write_int ( acc_len ) self . logger . info ( \"Reset GBE (UDP packetizer)\" ) self . cfpga . registers . gbe_rst . write_int ( 1 ) self . cfpga . registers . gbe_en . write_int ( 0 ) self . logger . info ( f \"Set spectra-per-packet to { spectra_per_packet } \" ) self . cfpga . registers . packetiser_spectra_per_packet . write_int ( spectra_per_packet ) self . logger . info ( f \"Set bytes-per-spectrum to { bytes_per_spectrum } \" ) self . cfpga . registers . packetiser_bytes_per_spectrum . write_int ( bytes_per_spectrum ) self . logger . info ( f \"Set quantization bit mode to { bits } -bits\" ) if bits == 1 : self . cfpga . registers . sel . write_int ( 0 ) elif bits == 4 : self . cfpga . registers . sel . write_int ( 1 ) self . logger . info ( f \"NOT YET IMPLEMENTED: Setting destination MAC address to { dest_mac } \" ) # TODO: set destination MAC address self . logger . info ( f \"Set destination IP address and port to { dest_ip } : { dest_prt } \" ) self . cfpga . registers . dest_ip . write_int ( str2ip ( dest_ip )) self . cfpga . registers . dest_prt . write_int ( dest_prt ) # Do we need to set mac address? #time.sleep(1.1) # dogmatically wait for regs to set before sending sync pulse self . sync_pulse () fft_of_count = self . cfpga . registers . fft_of_count . read_uint () if fft_of_count != 0 : self . logger . warning ( f \"FFT overflowing: count= { fft_of_count } \" ) else : self . logger . info ( f \"No FFT overflows detected\" ) self . logger . info ( \"Enabling 1 GbE output\" ) self . cfpga . registers . gbe_en . write_int ( 1 ) #self.logger.info(\"Leaving GBE reset high; pull it down manually once you think the negotiation has happened well!\") self . cfpga . registers . gbe_rst . write_int ( 0 ) gbe_overflow = self . cfpga . registers . tx_of_cnt . read_uint () if gbe_overflow : self . logger . warning ( f \"GbE transmit overflowing: count= { gbe_overflow } \" ) else : self . logger . info ( \"No GbE overflows detected\" ) self . logger . info ( \"Setup and tuning complete\" ) return","title":"tune"},{"location":"tuning-the-gateware/#the-communication-stack","text":"You may be wondering how Python is able to read from and write to FPGA registers.","title":"The communication stack"}]}