<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Design Overview - Sparrow Albatros</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../../assets/_mkdocstrings.css" rel="stylesheet" />
        <link href="../../stylesheets/extra.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Design Overview";
        var mkdocs_page_input_path = "gateware/gateware-design.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/python.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/languages/c.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Sparrow Albatros
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Embedded Software</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../embedded/data-collection/">Run the DAQ, collect data</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../embedded/tuning-the-gateware/">Tuning the gateware</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../embedded/digital-gain-coefficients-4bit/">Optimal Digital Gain Coefficients (4-bit)</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../embedded/dump-baseband/">Dumping baseband</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../embedded/dump-spectra/">Dumping correlated spectra</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../embedded/networking/">Networking</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Gateware</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../installing-the-toolflow/">Installing the Toolflow</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="#">Design Overview</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#foreword-on-the-simulink-casper-gateware-design-paradigm">Foreword on the Simulink-CASPER gateware design paradigm</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#adc-interface">ADC interface</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#pfb-fir">PFB FIR</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#fft">FFT</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#tvg1">TVG1</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#requantization">Requantization</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#payload-packetiser">Payload Packetiser</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#on-board-correlator">On-board correlator</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#correlator-accumulator-book-keeping">Correlator accumulator book-keeping</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#user-readwriteable-registers">User read/writeable registers</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#user-bram-interfaces">User BRAM interfaces</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../fft-note/">Note on FFT Implementation</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../gateware-modify-simulate/">Modify and Simulate</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../gateware-compile-synthesize-implement/">Compile, Synthesize, Implement</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Disk Images</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../installing-sparrow-albatros/">Installing Sparrow Albatros</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Data Specification</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../data-baseband/">Baseband</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../data-correlated-spectra/">Correlated Spectra</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Thesis</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../../thesis/ch1-thesis-overview/">Thesis Overview</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../thesis/ch2-science-intro/">Science Intro</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../thesis/ch3-albatros-experiment/">ALBATROS Experiment</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../thesis/ch4-snap-readout/">SNAP Readout System</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../thesis/ch5-sparrow-readout/">Sparrow Readout System</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../../thesis/ch6-field-results/">Field Results</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Sparrow Albatros</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Gateware</li>
      <li class="breadcrumb-item active">Design Overview</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="gateware-design-overview">Gateware Design Overview</h1>
<p>The digital signal processing logic starts at the ADCs, gets PFB'd (Filter + FFT), then splits into two signal paths:</p>
<ol>
<li>On board auto and cross correlations which can be read by the ARM core over SPI.</li>
<li>The logic re-quantizes the signal to 1 or 4 bits then selects and packages a subset of frequency channels into UDP packets which are streamed out of the Sparrow's 0'th SFP port. </li>
</ol>
<pre><code>                                     _--&gt; Correlator -&gt; Readable BRAM (SPI)
2x Analog Signal -&gt; ADC -&gt; PFB/FFT _/
                                    \_--&gt; 1bit quant |mux\_--&gt; UDP Packets (1GBE)
                                      --&gt; 4bit quant |   /
</code></pre>
<h2 id="foreword-on-the-simulink-casper-gateware-design-paradigm">Foreword on the Simulink-CASPER gateware design paradigm</h2>
<p>The Simulink (Matlab) and CASPER framework abstracts away the nitty gritty plumbing inherent to modern (2025) FPGA programming in regular text-based HDLs. There are good, bad, and ugly things about this. </p>
<p>The good: the user can jump right in and design, simulate, compile, implement, and synthesise a basic design targeted for supported hardware. The simulation aspect is worth emphasising because it's very easy to write a bug into logic design and it's often very hard to catch it without simulation. </p>
<p>The bad: it is impossible to track small diffs with modern version control tools (git) between two commits because the .slx files, being diagramatic rather than text based, are big and stored in compressed binary format. </p>
<p>The ugly side is that <a href="installing-the-toolchain.md">the toolchain</a> is very brittle and annoying to set up. You need a precise Ubuntu distribution, which means you can't just set it up on any linux machine without reinstalling the operating system and migrating all users to that new OS. Not to mention that you need to buy, install, set up and periodically renew licences for bulky (~300 GB), propriotary Xilinx (AMD) software (Vivado) and Matlab's Simulink software. </p>
<p>Once you have the toolchain running and are ready to assemble your first design, you'll notice that there are many different types of color-coded block. </p>
<ul>
<li>The yellow (CASPER) blocks are IO bocks. They map hardware pins to logic, define user programmable BRAMS and registers</li>
<li>The green (CASPER) blocks are (vaguely) DSP blocks. They implement logic to manipulate data. </li>
<li>The blue Xilinx blocks mix memory access and logic and are provided by Xilinx. These are primitive blocks provided by Xilinx, like operators or primitive data types in C.</li>
<li>Some white blocks implement simulation-only logic and tools to help develop and simulate the gateware.</li>
<li>The glossy grey blocks are user-defined <em>subsystems</em> that abstract away complexity, like a function in C or Python. Some white blocks also abstract user-defined logic, but these ones have 'mask parameters'. The values of mask parameters are set by the user before compilation, just like C macro-definitions. You can create one by highlighting some logic, righ-clicking, and selecting 'create subsystem from selection'. You can then turn a subsystem into a block with mask parameters by right-clicking the subsystem then Mask &gt; Create Mask.</li>
</ul>
<h2 id="adc-interface">ADC interface</h2>
<p>The ADC interface block, labelled <code>sparrow_adc</code>, provides the plumbing to link the ADCs' output pins with the design. The <code>sync_adc</code> register provides an interface for the python framework to sync the ADCs. The ADCs are programmed to sample at 250 MSPS but the fabric clock in this design is configured to run at 125 MSPS. To accomplish this clock domain crossing ADC samples are loaded into the fabric two at a time from each Pol (analog channel). The four output pins labels <code>data_a/b_0/1</code> denote a/b for pol0/1 and 0/1 for first and second samples within one fabric-clock period.
<img alt="image" src="https://github.com/user-attachments/assets/87739643-ff36-4363-bd93-22c0d8739f6b" /></p>
<h2 id="pfb-fir">PFB FIR</h2>
<p>The Polyphase Filter Bank Finite Impulse Response stage comprises four (number of inputs) sets of a series of four (number of taps) shift registers. Four frames worth of data from each ADC is windowed (point-wise multiplied by a vector of 'window coefficients'), then stacked and summed vertically. The output of this FIR filter feeds into the FFT. Each frame is 4096 (2^12) samples wide.
<img alt="image" src="https://github.com/user-attachments/assets/ac2e2d48-125d-45a5-8674-a8d59bbc0b28" /></p>
<p>The <code>sync</code> register is a user-writeable register which creates a 'sync pulse'. The sync pulse serves to align frames output by the PFB FIR filter with all of the logic downstream of it. This digital signal chain comprises an infinite loop of the same operations on consecutive data-frames and the sync pulse tells all the logical operators when the begining and end of each frame is. 
<img alt="image" src="https://github.com/user-attachments/assets/90f56cd2-8004-4443-863a-dab21486d713" /></p>
<h2 id="fft">FFT</h2>
<p>The FFT block implements a highly optimized Radix-2 decomposition Decimation In Frequency Fast Fourier Transform on parallel inputs. It takes a user-defined shift schedule as input (<code>pfb_fft_shift</code>) and records overflow events in a the register named <code>fft_of_count</code>. This FFT implementation takes advantage of the fact that a real-to-complex DFT has half as many outputs as inputs to balance the fact that it's being fed two samples from each ADC simultaneously. It also incorporates a de-scrambler so that the outputs are frequency-ordered complex samples (DIF FFTs naturally scramble their output (frequency domain samples) into bit-reversed order).
<img alt="image" src="https://github.com/user-attachments/assets/014abde5-64bb-4092-b4dc-71730cd42abf" /></p>
<p><em>TODO: inside the FFT</em></p>
<h2 id="tvg1">TVG1</h2>
<p>The first Test Vector Generator follows immediately downstream of the FFT. TVGs are gateware testing/debugging units that, when deployed in the field, are configured to litterally not do anything to the signal. (The two green <code>bus_create</code>/<code>bus_expand</code> blocks don't modify the data whatsoever but simply package the 36/72 parallel bit-lines together/appart.)</p>
<p><img alt="image" src="https://github.com/user-attachments/assets/e13b4aa7-9dc6-4208-8208-d4010bb2a379" /></p>
<p>A TVG enables the developer to mux in values from a user-writeable BRAM instead of the input. This module helps to test and debug gateware at both the simulation stage and in-Silica. The user controls whether to let actual data pass by writing to the <code>enable</code> register, and what data to replace it with by writing to the <code>data</code> BRAM. </p>
<p><img alt="image" src="https://github.com/user-attachments/assets/b5756967-1c7b-4401-be73-cd9cb4c15e45" /></p>
<h2 id="requantization">Requantization</h2>
<p>After the PFB (and TVG), each FFT'd signal branches three ways:</p>
<ul>
<li>The on-board correlator (skip ahead to the <a href="./#on-board-correlator">correlator section</a>)</li>
<li>4-bit requantization</li>
<li>1-bit requantization</li>
</ul>
<p>The latter two paths requantize the same complex digital signal to 1+1-bit and 4+4-bits (in parallel). Each of the real and imaginary components of each sample is quantized to one and four bits. </p>
<p>Data re-ordering and bussifying follows both one-bit and four-bit requantization stages. The output order is defined by the user so that the frequency channels to be packetized come out first. Both 1bit and 4bit data is 'bussified' onto an 8-bit bus. 8-bits is not wide enough for the 4-bit data (4 bits ADC0 real + 4 bits ADC0 imaginary + 4 bits ADC1 real + 4 bits ADC1 imaginary = 16 bits per clock), which is why the re-order stage must come before the bussifying stage. This limits the number of selectable channels to 1024 of 2048. </p>
<p><img alt="image" src="https://github.com/user-attachments/assets/848b1a53-7618-4bd3-bf80-89c43f1fb128" /></p>
<p>For example, if you were interested in channels 420 and above, you would configure the re-order and transpose stages to output signals illustrated in the timing diagram below. These are the signals you would see if you were to put a scope (or a logic analyzer) right before the MUX that selects whether to transmit 1-bit or 4-bit requantized signals to the next stage. The data lines below represent a byte-wide bus carrying quantized, complex data from both ADC channels, so there are 16 bits per frequency channel in 4-bit mode, and 4 bits per frequency channel in 1-bit mode. </p>
<script type="WaveDrom">
{
  "signal": [
    {"name": "clk", "wave": "p......"},
    {},
    {"name": "sync (4-bit)", "wave": "010...."},
    {"name": "four-bit data", "wave": "x.4.4.4", "data": ["Channel 420", "Channel 421", "Ch 422"], "phase": 0},
    {},
    {"name": "sync (1-bit)", "wave": "0.10..."},
    {"name": "one-bit data", "wave": "x..4444", "data": ["420/1", "422/3", "424/5", "426/7"], "phase": 0}
  ],
  "config": {
    "hscale": 2,
    "skin": "narrow"
  },
  "head": {
    "text": "Four-bit vs One-bit Data Streams with Sync Pulses"
  },
  "foot": {
    "text": "Data streams with single-pulse sync signals"
  }
}
</script>

<p>The one bit re-quantization logic is just a bunch of comparators (&gt; or &lt;). </p>
<p><img alt="image" src="https://github.com/user-attachments/assets/17cac276-9a76-438d-895c-24e5632b1e61" /></p>
<p>In parallel we quantize each component (real/imaginary) of each frequency channel to four bits. To exploit the full range of bits excersised by 4-bit quantization we apply digital gain to each frequency channel individually. The gain in each channel is set by the user through the <code>coeffs_pol0</code>/<code>coeffs_pol1</code> registers. The result is saturated against a floor and ceiling of the 4-bit range (-/+0.875) to wrapping (overflow). This image shows the logic for one of four quantization signal paths is shown.</p>
<p><img alt="image" src="https://github.com/user-attachments/assets/681d4e86-7b5c-44b6-9e64-b2f9b52ff31f" /></p>
<h2 id="payload-packetiser">Payload Packetiser</h2>
<p>The payload packetiser is a logical subsystem that creates payloads for the UDP packets which are broadcast over ethernet on SFP0. It bundles re-quantized data, either 1-bit or 4-bit quantized, with the spectrum number, which counts the number of FFTs which have been performed so that we can tell 1) whether we have dropped any UDP packets and 2) which UDP packets we have dropped. The logic that generates UDP packet headers and bundles these with our payloads is taken care of by a Xilinx IP. Our payload packetiser subsystem is directly upstream of this UDP packetiser logic and interfaces with it over three busses: data (8 bits wide), valid line (1 bit), end-of-frame line (EOF, 1 bit). Pull the valid line high simultaneously with valid data (data that you want to transmit) on your eight-lane bus, and low when the data on the data bus is trash. A UDP payload buffer fills up with valid data until you pull the end-of-frame line high simultaneously with the last valid data point. </p>
<p><img alt="image" src="https://github.com/user-attachments/assets/d4f9f32a-99fe-4119-9472-fe3d81c45a14" /></p>
<p><em>Caption: the payload packetizer subsystem is the white block labelled 'packetiser'. It has three input busses and three output busses, but it also takes input from readable and writable registers hidden beneath the subsystem mask.</em></p>
<p>For example, lets say we have one bit data and the only channels we care about are 420 through 427 inclusive, the timing diagram at the input of the payload packetiser, as we saw above in the requantization section, looks something like the following. </p>
<script type="WaveDrom">
{
  "signal": [
    {"name": "clk", "wave": "p......"},
    {"name": "data", "wave": "xx4444x", "data": ["420/1", "422/3", "424/5", "426/7"]},
    {"name": "sync", "wave": "010...."},
  ],
  "config": {
    "hscale": 2,
    "skin": "narrow"
  },
  "head": {
    "text": "Payload Packetiser Upstream"
  },
  "foot": {
    "text": "Timing diagram upstream of payload packetiser."
  }
}
</script>

<p>The sync pulse is only generated once and the logic is synchronised only once, so every subsequent input will have only the data line with anything of interest on it. The downstream logic knows to expect the pattern to repeat every 2048 clocks. The timing diagram downstream of the payload packetiser looks alternatively like either of the following three diagrams. </p>
<script type="WaveDrom">
{
  "signal": [
      {"name": "clk", "wave": "p......"},
    ["First",
      {"name": "data", "wave": "x333344", "data": ["Spec#","Spec#","Spec#","Spec#", "420/1", "422/3"]},
      {"name": "valid", "wave": "01....."},
      {"name": "EOF", "wave": "0......"},
    ],
    ["Middle",
      {"name": "data", "wave": "x4444xx", "data": ["420/1", "422/3","424/5", "426/7"]},
      {"name": "valid", "wave": "01...0."},
      {"name": "EOF", "wave": "0......"},
    ],
    ["Final",
      {"name": "data", "wave": "x4444xx", "data": ["420/1", "422/3","424/5", "426/7"]},
      {"name": "valid", "wave": "01...0."},
      {"name": "EOF", "wave": "0...10."},
    ]

  ],
  "config": {
    "hscale": 2,
    "skin": "narrow"
  },
  "head": {
    "text": "Payload Packetiser Downstream"
  },
}
</script>

<p>User facing registers tell the packetiser 1) how many FFT frames go into each packet and 2) how many clocks the valid pulse should last on each frame--which is directly related to the number of channels we want to preserve. Lets take a closer look at the logic that accomplishes the generation and pulsing.  </p>
<p><img alt="image" src="https://github.com/user-attachments/assets/7c499f13-fe07-4ca6-aa7e-0b83687c7edd" /></p>
<p>The sync and reset lines trigger a reset of the FFT-frame (/spectrum) counter, "spectra-counter". This counter is a UFix 43 bit counter, the most significant 32-bits are sliced and bussified onto a byte-wide bus. These four bytes populate the first four bytes of each UDP packet payload. This spectrum number is written to disk as per specified in our data format [need link to data format spec]. The 11th LSB is also sliced out and used to trigger a "new spectra" pulse. This pulse which anounces a new FFT-frame or "spectrum" is multi-purposes, it: </p>
<ul>
<li>synchronises the 32-bit spectrum number bussifier (so that the bits come out in sync with the first valid data point)  </li>
</ul>
<p><img alt="image" src="https://github.com/user-attachments/assets/84a8d566-3856-4534-b621-6db6178840a4" /></p>
<ul>
<li>increments another counter, "packet_spec_counter", by one which, in turn,  <ul>
<li>triggers the valid line on the first spectrum of the packet to include the spectrum number</li>
<li>triggers the end-of-frame line on the last spectrum of the packet to tell the UDP packetizer to bundle and send the buffered payload. The user sets the spectra per packet from python by writing an integer to the (above) yellow "spectra_per_packet" register. </li>
</ul>
</li>
</ul>
<p><img alt="image" src="https://github.com/user-attachments/assets/e536e121-464c-4b61-8093-ad520ceb6ea3" /></p>
<ul>
<li>triggers a pulse-extender that pulls high the valid line for the number of clocks required to for each spectrum. The user sets the number of bytes in each spectrum by writing said value into the (above) yellow "bytes_per_spectrum" register. The number of bytes in each spectrum is a function of the number of channels saved as well as the re-quantization depth (4+4 bits vs 1+1 bit per sample). </li>
</ul>
<p><img alt="image" src="https://github.com/user-attachments/assets/8282f16c-8bed-42e3-9695-06b7bc48a5c7" /></p>
<p>Once the data is packetized, it's checked into the <code>one_gbe</code> block, and the CASPER framework takes care of the plumbing to pipe this into the correct Xilinx IP that implements UDP packetizing, and routs it to the correct physical SFP port (SFP0). In the image, a helpful user-readable buffer-overflow counter <code>tx_of_cnt</code> keeps track of overflowing packets, and the signal coming out of our user-defined packetizer also routs <em>in simulation only</em> to a virtual oscilascope.</p>
<p><img alt="image" src="https://github.com/user-attachments/assets/81af2f1e-c9aa-4a68-b5d5-fb50447d2e5a" /></p>
<h2 id="on-board-correlator">On-board correlator</h2>
<p>The signal path branches after the FFT. In the previous section we looked at re-quantization, data selection, and UDP packetizing, here we look at the second branch down-stream of the FFT: the correlator. The correlator computes auto- and cross-correlations of both channelized signals. The power in each pol is computed with a simple accumulator. Real and imaginary components of the cross correlation are similarly calculated. The result is dumped periodically into addressable BRAM registers <code>pol00</code>, <code>pol11</code>, <code>pol01r</code>, <code>pol01i</code>. Mathematically, the correlator computes autocorrelations, </p>
<div class="arithmatex">\[P_{00}[k] = \sum_{l=0}^{N-1}|y_0[k,l]|^2,\]</div>
<p>and cross correlations,</p>
<div class="arithmatex">\[P_{01}[k] = \sum_{l=0}^{N-1}y_0[k,l] \cdot y_1[k,l]^\ast,\]</div>
<p>where <span class="arithmatex">\(y_s[k,l]\)</span> is the <span class="arithmatex">\(l\)</span>'th spectrum's <span class="arithmatex">\(k\)</span>'th frequency channel's data from pol-<span class="arithmatex">\(s\)</span>. Real and imaginary terms of the cross-correlations are accumulated in seperate BRAMs as all the arithmetic is carried out on real integers. </p>
<p><img alt="image" src="https://github.com/user-attachments/assets/b76d2983-9580-4acd-8d1c-ef4f29060695" /></p>
<h3 id="correlator-accumulator-book-keeping">Correlator accumulator book-keeping</h3>
<p>It's important to do some book-keeping to make sure the correlator BRAMs don't overflow. If the signal is <code>U37_36</code> and the accumulator BRAM is <code>U64_35</code> then we can only accumulate <code>2^28</code> samples samples (per channel), in seconds the accumulator BRAM fills up in <code>2^28*4096/250e6 = 4398</code> seconds, which is over an hour. We will never want to accumulate more than a few seconds. </p>
<p>However, the calculus changes if we implement FFT bit-growth to avoid doing a full shift schedule. If we grow the data by one bit on every FFT butterfly stage we're eating up 12 bits, which means that it becomes logically possible for the accumulator BRAMs to overflow after only one second, which is unacceptable. This means we either have to grow our BRAMs or do something to reduce the bit depth of these numbers. </p>
<p>The latest version of the firmware implements 8-bits of bitgrowth, the full twelve is not needed as our 12 bit data is already LSB-padded by four bits in the stack-and-sum stage of the PFB (upstream of the FFT). After eight bits of growth in the FFT the data is 24 bits wide; four LSBs are sliced off in the correlator branch so that it fits snugly in the correlator's accumulators. </p>
<h2 id="user-readwriteable-registers">User read/writeable registers</h2>
<p>We make use of all named addressable registers in this design so it's worth knowing what each of them does. (The left-pointing pentagonal tags mean <em>goto</em> and are paired with right-pointing ones of the same name.)</p>
<ul>
<li><code>gbe_en</code> GigaBit Ethernet interface ENable. Single bit, 0 for disable, 1 for enable.</li>
<li><code>gbe_rst</code> GigaBit Ethernet interface ReSeT. Single bit. Resets on transition from 0 to 1. </li>
<li><code>pack_rst</code> PACKetizer ReSeT. Single bit to reset packetizer logic, including spectrum counter, on transition from 0 to 1.</li>
<li><code>cnt_rst</code> accumulator CoNTroller ReSeT. Single bit to reset accumulator control logic.</li>
<li><code>acc_len</code> ACCumulation LENgth. UFix32 sets the number of spectra to accumulate for each correlation. (How long to integrate data, if you prefer to think that way.) This number times 4096/250e6 gives the accumulation time in seconds.</li>
<li><code>dest_ip</code> Sets the DESTination IP addresss.</li>
<li><code>dest_prt</code> Sets the DESTination PoRT.</li>
<li><code>sync_cnt</code> (read only) does exactly nothing because I removed the logic that periodically syncs all the logic. Instead it just syncs stuff once on initialization. </li>
<li><code>acc_cnt</code> (read_only) ACCumulation CouNTer. Counts the number of spectra that have been accumulated.</li>
</ul>
<p><img alt="image" src="https://github.com/user-attachments/assets/dc35ab2c-af51-4d35-8757-cc842d6fa51f" /></p>
<p>Other user read/writeable registers are scattered throughout the design. </p>
<p><code>sync_adc</code> SYNChronize ADC logic. Single bit pulse active on transition from 0 to 1.</p>
<p><img alt="image" src="https://github.com/user-attachments/assets/e336dff3-952b-436f-8287-6e3adeff3513" /></p>
<p><code>sync</code> Creates SYNChronizing pulse that aligns each set of the DSP chain. Single bit pulse, active on transition from 0 to 1.</p>
<p><img alt="image" src="https://github.com/user-attachments/assets/32370d0a-f7d8-4995-b09a-27cb45661cee" /></p>
<p><code>pfb_fft_shift</code> UFix12 determines the shift schedule. Each bit represents 0 for no shift, 1 for shift. Currently we have a full shift schedule. We may want to implement a bit-growth FFT so that we can have our cake (low noise floor from not shifting) and eat it too (no FFT overflows).</p>
<p><img alt="image" src="https://github.com/user-attachments/assets/cb700aac-7c46-4e74-89d4-23321878be34" /></p>
<p><code>fft_of_count</code> (read only) FFT OverFlow COUNTer. Every time there's an overflow event in a frame +1 is added to this UFix32 register. </p>
<p><img alt="image" src="https://github.com/user-attachments/assets/4000552f-d857-4f4f-9528-039c2766a375" /></p>
<p><code>sel</code> SELects which requantization bit mode to choose from: 0 for 1bit, 1 for 4bits. </p>
<p><img alt="image" src="https://github.com/user-attachments/assets/db427b50-23b6-4954-b8ca-67176bf47ce7" /></p>
<p><code>tvg1_enable</code> Enables the the TVG right after the FFT stage. 0 to pass actual data, 1 to pass values read sequentially from the BRAM labelled <code>data</code>.  </p>
<p><img alt="image" src="https://github.com/user-attachments/assets/965644f1-5e7f-4e35-bacd-4cbea44bc282" /></p>
<p><code>tvg16bit_enable</code> enables the the TVG right after the 4bit requantization stage. Write 0 to pass actual data, 1 to pass values read sequentially from the BRAM labelled <code>data</code>. </p>
<p><img alt="image" src="https://github.com/user-attachments/assets/92f41e80-d411-49e6-a489-9bc1cd704244" /></p>
<p><code>four_bit_quant_clip_count</code> is a readable register that counts the amount of four-bit clipping events. It increments by one when one of the four re/im pol0/pol1 values saturates four bit re-quantizer. </p>
<p><img alt="image" src="https://github.com/user-attachments/assets/61d9f33b-769a-4a5d-a905-d28dbd13ec01" /></p>
<p><code>spectra_per_packet</code> specifies the amount of spectra to include in each UDP packet. We're not using jumbo frames so we limit the spectra per packet to a number small enough for regular ethernet UDP frames. This register is written to at the tuning stage. The register holds an unsigned 32 bit integer, but only the five least significant bits are used. </p>
<pre><code class="language-python">MTU=1500 # max number of bytes in a packet
assert spectra_per_packet &lt; (1&lt;&lt;5), &quot;spec-per-pack too large for slice, aborting&quot;
assert spectra_per_packet * bytes_per_spectrum &lt;= MTU-8, &quot;Packets too large, will cause fragmentation&quot;
</code></pre>
<p><img alt="image" src="https://github.com/user-attachments/assets/ce1b0a74-604e-4658-a7f9-52226a5e6038" /></p>
<p><code>bytes_per_spectrum</code> </p>
<p><img alt="image" src="https://github.com/user-attachments/assets/8a3a2dc9-285b-496d-9a9a-5f2839976327" /></p>
<p><code>tx_of_cnt</code> <em>TODO</em></p>
<p><img alt="image" src="https://github.com/user-attachments/assets/63ea5bae-0e51-4440-b4ee-a6fb8e3c42be" /></p>
<h2 id="user-bram-interfaces">User BRAM interfaces</h2>
<p><code>tvg1_data</code> <em>TODO</em></p>
<p><img alt="image" src="https://github.com/user-attachments/assets/f1de49f6-9061-4ba1-b7b4-c27abf0b19de" /></p>
<p><code>tvg16bit_data</code> <em>TODO</em></p>
<p>Examples of this TVG's use can be found <a href="https://github.com/ALBATROS-Experiment/sparrow-albatros/blob/main/software/tvg_4bitq.py">here</a>. </p>
<details>
<summary>View example use</summary>


<pre><code class="language-python">&quot;&quot;&quot;Example of writing to TVG&quot;&quot;&quot;

#import numpy as np
#
#fpga.read(&quot;tvg16bit_data&quot;, 16, offset=0)
#
## 32 bit registers but 16bit LSB are sliced (i.e. 16 MSB are sliced off)
#tvgbytes=np.ndarray.tobytes(np.array([0x0,0x0,0x05,0xaf]*(1&lt;&lt;11),dtype='&gt;i1'))
#
#fpga.write(&quot;tvg16bit_data&quot;, tvgbytes, offset=0)

#def pack_into_4bit_tvg(pol0r:bytes, pol0i:bytes, pol1r:bytes, pol1i:bytes):
#    &quot;&quot;&quot;Pack complex arrays into TVG right after 4bit requantizer&quot;&quot;&quot;
#    for p in (pol0r,pol0i,pol1r,pol1i):assert len(p)==(1&lt;&lt;10)
#    zeros=b'\x00'*(1&lt;&lt;10)

###################

TVG_FFT_SBRAM_SHAPE = (1&lt;&lt;11,)

def pack_into_64(pol0r, pol0i, pol1r, pol1i):
    &quot;&quot;&quot;Pack complex arrays into the TVG right after FFT block.

    Numpy doesn't know about fix_16_15's, so we'll just use int16
    and pretend that they are the fractional part, i.e. that our int16s
    represent that number divided by (1&lt;&lt;15)=32_768.

    :param np.ndarray(int16) pol0r:
        Real componant of FFT'd pol0
    :param np.ndarray(int16) pol0i:
        Imaginary componant of FFT'd pol0
    :param np.ndarray(int16) pol1r:
        Real componant of FFT'd pol1
    :param np.ndarray(int16) pol1i:
        Imaginary componant of FFT'd pol1

    :returns: Bytearray, ready for writing to sbram.
    &quot;&quot;&quot;
    # TODO: figure out endianness...
    for pol in (pol0r, pol0i, pol1r, pol1i):
        assert pol.shape==TVG_FFT_SBRAM_SHAPE, &quot;Pol shape must be compatible with sbram shape&quot;
    out = np.array([pol0r, pol0i, pol1r, pol1i], dtype='&gt;i2').T.flatten()
    return out.tobytes()


def pack_tvg_fft_ramp_pol0r(fpga):
    &quot;&quot;&quot;Write to the TVG data register&quot;&quot;&quot;
    pol0r = np.arange(1&lt;&lt;11, dtype='&gt;i2')
    pol0i = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    pol1r = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    pol1i = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    fpga.write(&quot;tvg1_data&quot;, pack_into_64(pol0r, pol0i, pol1r, pol1i), offset=0)
    return

def pack_tvg_fft_ramp_pol0i(fpga):
    pol0r = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    pol0i = np.arange(1&lt;&lt;11, dtype='&gt;i2')
    pol1r = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    pol1i = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    fpga.write(&quot;tvg1_data&quot;, pack_into_64(pol0r, pol0i, pol1r, pol1i), offset=0)
    return

def pack_tvg_fft_ramp_pol1r(fpga):
    pol0r = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    pol0i = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    pol1r = np.arange(1&lt;&lt;11, dtype='&gt;i2')
    pol1i = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    fpga.write(&quot;tvg1_data&quot;, pack_into_64(pol0r, pol0i, pol1r, pol1i), offset=0)
    return

def pack_tvg_fft_ramp_pol1i(fpga):
    pol0r = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    pol0i = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    pol1r = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    pol1i = np.arange(1&lt;&lt;11, dtype='&gt;i2')
    fpga.write(&quot;tvg1_data&quot;, pack_into_64(pol0r, pol0i, pol1r, pol1i), offset=0)
    return

def pack_tvg_fft_const_pol0r(fpga):
    pol0r = np.ones(1&lt;&lt;11, dtype='&gt;i2')
    pol0i = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    pol1r = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    pol1i = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    fpga.write(&quot;tvg1_data&quot;, pack_into_64(pol0r, pol0i, pol1r, pol1i), offset=0)
    return

def pack_tvg_fft_const_pattern2(fpga):
    pol0r = np.ones(1&lt;&lt;11, dtype='&gt;i2')
    pol0i = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    pol1r = np.ones(1&lt;&lt;11, dtype='&gt;i2') * 2
    pol1i = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    fpga.write(&quot;tvg1_data&quot;, pack_into_64(pol0r, pol0i, pol1r, pol1i), offset=0)
    return

def pack_tvg_fft_const_pattern3(fpga):
    pol0r = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    pol0r[np.array((400,401,403,406,410,415,421,428))] = 1
    pol0i = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    pol1r = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    pol1i = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    fpga.write(&quot;tvg1_data&quot;, pack_into_64(pol0r, pol0i, pol1r, pol1i), offset=0)
    return

def pack_tvg_fft_pol0r(fpga,pol0r):
    pol0i = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    pol1r = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    pol1i = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    fpga.write(&quot;tvg1_data&quot;, pack_into_64(pol0r, pol0i, pol1r, pol1i), offset=0)
    return

def pack_tvg_fft_pol0r_pol1r(fpga,pol0r,pol1r):
    pol0i = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    pol1i = np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    fpga.write(&quot;tvg1_data&quot;, pack_into_64(pol0r, pol0i, pol1r, pol1i), offset=0)
    return

def zeros_tag(chan_idx):
    arr=np.zeros(1&lt;&lt;11, dtype='&gt;i2')
    arr[chan_idx] = 1&lt;&lt;14
    arr=np.array(arr,dtype='&gt;i2')
    return arr

def negrailed_tag(chan_idx):
    arr=np.array(np.ones(1&lt;&lt;11) * (-1&lt;&lt;14),dtype='&gt;i2')
    arr[chan_idx] = 1&lt;&lt;14
    arr=np.array(arr,dtype='&gt;i2')
    return arr

if __name__==&quot;__main__&quot;:
    # tests
    pass

#pols=[np.concatenate([[1]*44,[-1],[1]*((1&lt;&lt;11)-45)]),np.concatenate([[1]*45,[-1],[1]*((1&lt;&lt;11)-46)]),np.ones(1&lt;&lt;11),np.ones(1&lt;&lt;11)];fpga.write(&quot;tvg1_data&quot;,pack_into_64(pols[0],pols[1],pols[2],pols[3]),offset=0)


</code></pre>

</details>

<p><img alt="image" src="https://github.com/user-attachments/assets/04c53ba1-43c8-422d-bc29-7924458afd7a" /></p>
<p><code>four_bit_quant_coeffs_pol0/1</code> <em>TODO</em></p>
<p><img alt="image" src="https://github.com/user-attachments/assets/7125f44c-2cc7-484d-9558-ac815d39058f" /></p>
<p><img alt="image" src="https://github.com/user-attachments/assets/816aa56a-8e1f-4ce0-bb5f-e6100a04847f" /></p>
<p><code>one_bit_reorder_map1</code> <em>TODO</em></p>
<p><img alt="image" src="https://github.com/user-attachments/assets/5f86f08d-6f42-462d-9d6c-76480f68d785" /></p>
<p><code>four_bit_reorder_map1</code> <em>TODO</em></p>
<p><img alt="image" src="https://github.com/user-attachments/assets/a05cf769-554a-4171-aab9-7abd4db8154f" /></p>
<p><code>pol00</code>, <code>pol11</code>, <code>pol01r</code>, <code>pol01i</code> <em>TODO</em></p>
<p><img alt="image" src="https://github.com/user-attachments/assets/0badcd5c-f85f-4ed7-b32b-421b398a638c" /></p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../installing-the-toolflow/" class="btn btn-neutral float-left" title="Installing the Toolflow"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../fft-note/" class="btn btn-neutral float-right" title="Note on FFT Implementation">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../installing-the-toolflow/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../fft-note/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="../../wavedrom-init.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
